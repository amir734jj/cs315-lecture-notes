###########################################################
#       Lab 9 (B) - column major
#
#   Name:
#   Date:
#
#   Description:
#       1. use create_col_matrix to create and read a column major matrix
#       2. store the base address, height, and width in static memory (should be done in main)
#       3. use print_col_matrix to print the matrix
#       4. use get_element to print the element from the matrix
#       5. print the element returned by get_element
#
#   High level design:
#       from main call: array base address, array height, array width <-- create_col_matrix()
#           from create_col_matrix call: array base address, array height, array width <-- read_col_matrix()
#
#       from main call: null <-- print_col_matrix(array base address, array height, array width)
#
#       from main: prompt and read height index (row index) and width index (column index)  <--> use these row & column index as argument IN to call 
#                                                                                                get_element subprogram
#
#       from main call: element <-- get_element(array base address, array height, array width, height index, width index)
#
#       from main: print element
#
###########################################################
#       Register Usage
#   $t0  Holds array base address (temporarily)
#   $t1  Holds array height (temporarily)
#   $t2  Holds width height (temporarily)
#   $t3  Holds height index <--> row index, will be used to call get_element subprogram
#   $t4  Holds width index <--> column index, will be used to call get_element subprogram
#   $t5  Holds array content at a given index
#   $t6
#   $t7
#   $t8
###########################################################
        .data
array_pointer_p:    .word 0     # holds address of multi-dimensional dynamic array pointer (address)
array_height_p:     .word 0     # hold height of multi-dimensional dynamic array (value)
array_width_p:      .word 0     # hold width of multi-dimensional dynamic array (value)

row_p:              .asciiz     "Enter row index (less than array height): "
column_p:           .asciiz     "Enter column index (less than array width): "
element_p:          .asciiz     "Element is: "
###########################################################
        .text
main:

# calling a subprogram create_array to dynamically create multi-dimensional array
    addi $sp, $sp, -4       # allocate one word for $ra
    sw $ra, 0($sp)          # store $ra on stack

                            # no register to backup in the stack

    addi $sp, $sp, -12      # allocate words for the arguments
                            # arguments IN:  NONE
                            # arguments OUT: array base address, array height, array width  <-- 3 words

    jal create_col_matrix   # call subprogram create_col_matrix

    lw $t0, 0($sp)          # read array base address from stack
    lw $t1, 4($sp)          # read array height from stack
    lw $t2, 8($sp)          # read array width from stack
    addi $sp, $sp, 12       # deallocate words for the arguments IN & OUT

                            # we did not backup a register, so there is no register restoring

    lw $ra, 0($sp)          # load $ra from stack
    addi $sp, $sp, 4        # deallocate word for $ra


# save array base, array height, array width in static variables,
# if we store them in registers only, we might lose the array base address array sizes
    la $t9, array_pointer_p
    sw $t0, 0($t9)          # store base address

    la $t9, array_height_p
    sw $t1, 0($t9)          # store array height

    la $t9, array_width_p
    sw $t2, 0($t9)          # store array width


# calling a subprogram print_col_matrix to print the array contents
# load base, array height, array length from static memory
    la $t9, array_pointer_p
    lw $t0, 0($t9)          # store base address

    la $t9, array_height_p
    lw $t1, 0($t9)          # store array height

    la $t9, array_width_p
    lw $t2, 0($t9)          # store array width


    addi $sp, $sp, -4       # allocate one word for $ra
    sw $ra, 0($sp)          # store $ra on stack

                            # no register to backup in the stack

    addi $sp, $sp, -12      # allocate words for the arguments
                            # arguments IN: array base address, array height, array width   <-- 3 words
                            # arguments OUT: NONE

    sw $t0, 0($sp)          # store array base address to stack
    sw $t1, 4($sp)          # store array height to stack
    sw $t2, 8($sp)          # store array width to stack

    jal print_col_matrix    # call subprogram print_col_matrix
    addi $sp, $sp, 12       # deallocate words for the arguments IN & OUT

                            # we did not backup a register, so there is no register restoring

    lw $ra, 0($sp)          # load $ra from stack
    addi $sp, $sp, 4        # deallocate word for $ra


# prompt for element index
    li $v0, 4               # prompt for element height index
    la $a0, row_p
    syscall

    li $v0, 5               # read integer height index (or row index)
    syscall

    move $t3, $v0           # move height index into register $t3

    li $v0, 4               # prompt for element width index
    la $a0, column_p
    syscall

    li $v0, 5               # read integer width index (or column index)
    syscall

    move $t4, $v0           # move width index into register $t4


# calling a subprogram get_element to return array element at given index
# load base, array height, array length from static memory
    la $t9, array_pointer_p
    lw $t0, 0($t9)          # store base address

    la $t9, array_height_p
    lw $t1, 0($t9)          # store array height

    la $t9, array_width_p
    lw $t2, 0($t9)          # store array width


    addi $sp, $sp, -4       # allocate one word for $ra
    sw $ra, 0($sp)          # store $ra on stack

                            # no register to backup in the stack

    addi $sp, $sp, -24      # allocate words for the arguments
                            # arguments IN: array base address, array height, array width, array height index, array width index    <-- 5 words
                            # arguments OUT: array element at given index                                                           <-- 1 word

    sw $t0, 0($sp)          # store array base address to stack
    sw $t1, 4($sp)          # store array height to stack
    sw $t2, 8($sp)          # store array width to stack
    sw $t3, 12($sp)         # store array height index to stack
    sw $t4, 16($sp)         # store array width index to stack

    jal get_element         # call subprogram get_element

    lw $t5, 20($sp)         # load array content at given index
    addi $sp, $sp, 24       # deallocate words for the arguments IN & OUT

                            # we did not backup a register, so there is no register restoring

    lw $ra, 0($sp)          # load $ra from stack
    addi $sp, $sp, 4        # deallocate word for $ra

# print returned array element
    li $v0, 4               # print element is:
    la $a0, element_p
    syscall

    li $v0, 1               # print returned array element
    move $a0, $t5
    syscall

mainEnd:
    li $v0, 10
    syscall                 # Halt
###########################################################
#       create_col_matrix subprogram
#
#   Subprogram description:
#       ask the user for a height and width, then dynamically
#       allocate space for a matrix of words with the given dimensions (using system call 9)
#
#       call read_col_matrix to fill the matrix
#
#   High level design:
#       prompt and read array height and array width
#       array base address <-- allocate # of bytes: array height * array width * 4
#
#       call: null <-- read_col_matrix(array base address, array height, array width)
#
#       return array base address, array height, array width
#
###########################################################
#       Arguments IN and OUT of subprogram
#   $sp+0  Holds array base address (OUT)
#   $sp+4  Holds array base height (OUT)
#   $sp+8  Holds array base width (OUT)
###########################################################
#       Register Usage
#   $t0 Holds matrix height
#   $t1 Holds matrix width
###########################################################
        .data
create_col_matrix_height_p:     .asciiz "Enter matrix height: "
create_col_matrix_width_p:      .asciiz "Enter matrix width: "
create_col_matrix_invalid_p:    .asciiz "Invalid dimension\n"
###########################################################
        .text
create_col_matrix:

# prompt and read matrix height
create_col_matrix_height_loop:
    li $v0, 4               # prompt for height
    la $a0 create_col_matrix_height_p
    syscall

    li $v0, 5               # read integer value of height
    syscall

    bgtz $v0, create_col_matrix_height_valid    # check if height is valid

    li $v0, 4               # print error message
    la $a0, create_col_matrix_invalid_p
    syscall

    b create_col_matrix_height_loop             # branch unconditionally back to beginning of the loop (invalid dimension)

create_col_matrix_height_valid:
    move $t0, $v0           # move height value into register $t0
    sw $v0, 4($sp)          # store height for return at 4($sp)

# prompt and read matrix height
create_col_matrix_width_loop:
    li $v0, 4               # prompt for width
    la $a0, create_col_matrix_width_p
    syscall

    li $v0, 5               # read integer value of width
    syscall

    bgtz $v0, create_col_matrix_width_valid     # check if width is valid

    li $v0, 4               # print error message
    la $a0, create_col_matrix_invalid_p
    syscall

    b create_col_matrix_width_loop              # branch unconditionally back to beginning of the loop (invalid dimension)

create_col_matrix_width_valid:
    move $t1, $v0           # move width value into register $t1
    sw $v0, 8($sp)          # store width for return at 8($sp)


# allocate space for matrix
    mul $a0, $t0, $t1       # $a0 <-- height * width
    sll $a0, $a0, 2         # $a0 <-- 4 * (height * width)
    li $v0, 9
    syscall                 # allocate matrix using system call 9

    sw $v0, 0($sp)          # store base address for return

# calling subprogram read_col_matrix
    addi $sp, $sp, -4       # allocate one word for $ra
    sw $ra, 0($sp)          # store $ra on stack

                            # no register to backup in the stack

    addiu $sp, $sp, -12     # allocate words for the arguments
                            # arguments IN: array base address, matrix height, matrix width <-- 3 words
                            # arguments OUT: NONE

    sw $v0, 0($sp)          # store array base address
    sw $t0, 4($sp)          # store array height
    sw $t1, 8($sp)          # store array width

    jal read_col_matrix     # call subprogram read_col_matrix
    addiu $sp, $sp, 12      # deallocate words for the arguments IN & OUT

                            # we did not backup a register, so there is no register restoring

    lw $ra, 0($sp)          # load $ra from stack
    addi $sp, $sp, 4        # deallocate word for $ra

create_col_matrix_end:
    jr $ra                  # jump back to the main
###########################################################
#       read_col_matrix subprogram
#
#   Subprogram description:
#       This subprogram reads words into a matrix until the matrix is full
#       elements must be stored in column-major order
#
#   Pseudo-code:
#       for (int i = 0; i < array height; i++) {
#           for (int j = 0; j < array width; j++) {
#
#               prompt and read array value
#
#               row index = i
#               column index = j
#
#               memory[array base address + 4 * (array height * column index + row index)] = array value
#
#           }
#       }
#
###########################################################
#       Arguments IN and OUT of subprogram
#   $sp+0  Holds array base address (IN)
#   $sp+4  Holds array base height (IN)
#   $sp+8  Holds array base width (IN)
###########################################################
#       Register Usage
#   $t0 Holds matrix base address
#   $t1 Holds matrix height
#   $t2 Holds matrix width
###########################################################
        .data
read_col_matrix_prompt_p:   .asciiz "Enter an integer: "
###########################################################
        .text
read_col_matrix:
# save arguments so we do not lose them
    lw $t0, 0($sp)          # load array base address
    lw $t1, 4($sp)          # load array height
    lw $t2, 8($sp)          # load array width

    li $t3, 0               # initialize outer-loop counter to 0

read_col_matrix_loop_outer:
    bge $t3, $t1, read_col_matrix_loop_outer_end

    li $t4, 0               # initialize inner-loop counter to 0

read_col_matrix_loop_inner:
    bge $t4, $t2, read_col_matrix_loop_inner_end

#################################################
# calculate index address
#   i   =   b + s * (e * k + n')
#   b   -   base, $t0
#   s   -   element size, 4 (4 bytes per word)
#   e   -   height, $t1
#   k   -   column index, $t3
#   n'  -   row index, $t4
#   i   -   index address, $t5 (to be calculated)
#################################################
    mul $t5, $t4, $t1       # $t5 <-- e * k
    add $t5, $t5, $t3       # $t5 <-- e * k + n'
    sll $t5, $t5, 2         # $t5 <-- s * (e * k + n')
    add $t5, $t0, $t5       # $t5 <-- b + s * (e * k + n') = i

    li $v0, 4               # prompt for number
    la $a0, read_col_matrix_prompt_p
    syscall

    li $v0, 5               # read a integer number
    syscall

    sw $v0, 0($t5)          # store input number into array

    addiu $t4, $t4, 1       # increment inner-loop counter

    b read_col_matrix_loop_inner    # branch unconditionally back to beginning of the inner loop

read_col_matrix_loop_inner_end:
    addiu $t3, $t3, 1       # increment outer-loop counter

    b read_col_matrix_loop_outer    # branch unconditionally back to beginning of the outer loop

read_col_matrix_loop_outer_end:

read_col_matrix_end:
    jr $ra                  # jump back to the main
###########################################################
#       print_col_matrix subprogram
#
#   Subprogram description:
#       This subprogram will iterated through a column major matrix and
#       prints values of a column-major matrix
#
#       Note:
#           ASCII code 9 is a horizontal tab.
#           ASCII code 10 is a newline character.
#           system call to print a character is: 11
#
#   Pseudo-code:
#       for (int i = 0; i < array height; i++) {
#           for (int j = 0; j < array width; j++) {
#
#               row index = i
#               column index = j
#
#               array value = memory[array base address + 4 * (array height * column index + row index)]
#
#               print array value
#           }
#       }
#
###########################################################
#       Arguments IN and OUT of subprogram
#   $sp+0  Holds array base address (IN)
#   $sp+4  Holds array base height (IN)
#   $sp+8  Holds array base width (IN)
###########################################################
#       Register Usage
#   $t0 Holds matrix base address
#   $t1 Holds matrix height
#   $t2 Holds matrix width
#   $t3 Holds outer-loop counter
#   $t4 Holds inner-loop counter
#   $t5 Holds temporarily value
###########################################################
        .data
###########################################################
        .text
print_col_matrix:
# save arguments so we do not lose them
    lw $t0, 0($sp)          # load array base address
    lw $t1, 4($sp)          # load array height
    lw $t2, 8($sp)          # load array width

    li $t3, 0
print_col_matrix_loop_outer:
    bge $t3, $t1, print_col_matrix_loop_outer_end


    li $t4, 0
print_col_matrix_loop_inner:
    bge $t4, $t2, print_col_matrix_loop_inner_end

#################################################
# calculate index address
#   i   =   b + s * (e * k + n')
#   b   -   base, $t0
#   s   -   element size, 4 (4 bytes per word)
#   e   -   height, $t1
#   k   -   column index, $t4
#   n'  -   row index, $t3
#   i   -   index address, $t5 (to be calculated)
#################################################
    mul $t5, $t4, $t1       # $t5 <-- e * k
    add $t5, $t5, $t3       # $t5 <-- e * k + n'
    sll $t5, $t5, 2         # $t5 <-- s * (e * k + n')
    add $t5, $t0, $t5       # $t5 <-- b + s * (e * k + n') = i

    lw $a0, 0($t5)          # load a value from array into register $a0
    li $v0, 1
    syscall

    li $a0, 9               # ASCII code 9 - horizontal tab character
    li $v0, 11
    syscall

    addiu $t4, $t4, 1       # increment inner-loop counter

    b print_col_matrix_loop_inner   # branch unconditionally back to beginning of the inner loop

print_col_matrix_loop_inner_end:
    li $a0, 10              # ASCII code 10 - newline character
    li $v0, 11
    syscall

    addiu $t3, $t3, 1       # increment outer-loop counter

    b print_col_matrix_loop_outer   # branch unconditionally back to beginning of the outer loop

print_col_matrix_loop_outer_end:

print_col_matrix_end:
    jr $ra                  # jump back to the main
###########################################################
#       get_element
#
#   Subprogram description:
#       returns the element at the given row/column if the given row or column is out of bounds, print
#       an error and return 0
#
#   Pseudo-code:
#       array value = memory[array base address + 4 * (array height * column index + row index)]
#
#       return array value
#
###########################################################
#       Arguments IN and OUT of subprogram
#   $sp+0  Holds array base address (IN)
#   $sp+4  Holds array base height (IN)
#   $sp+8  Holds array base width (IN)
#   $sp+12  Holds row index (IN)
#   $sp+16  Holds column index (IN)
#   $sp+20  return matrix element (OUT)
###########################################################
#       Register Usage
#   $t0 Holds matrix base address
#   $t1 Holds matrix height
#   $t2 Holds matrix width
#   $t3 Holds row index
#   $t4 Holds column index
#   $t5 Holds temporarily value
###########################################################
        .data
get_element_invalid_index_p:    .asciiz     "Invalid index\n"
###########################################################
        .text
get_element:
# save arguments so we do not lose them
    lw $t0, 0($sp)          # load array base address
    lw $t1, 4($sp)          # load array height
    lw $t2, 8($sp)          # load array width
    lw $t3, 12($sp)         # load row index
    lw $t4, 16($sp)         # load column index

    li $t6, -999            # initialize element to return to -999

    bge $t3, $t1, get_element_invalid_index # index is invalid if row index is greater than or equal to height
    bge $t4, $t2, get_element_invalid_index # index is invalid if column index is greater than or equal to width

get_element_valid:

#################################################
# calculate index address
#   i   =   b + s*(e*k + n')
#   b   -   base, $t0
#   s   -   element size, 4 (4 bytes per word)
#   e   -   column index, $t4
#   k   -   height, $t1
#   n'  -   row index, $t3
#   i   -   index address, $t5 (to be calculated)
#################################################
    mul $t5, $t4, $t1       # $t5 <-- e * k
    add $t5, $t5, $t3       # $t5 <-- e * k + n'
    sll $t5, $t5, 2         # $t5 <-- s * (e * k + n')
    add $t5, $t0, $t5       # $t5 <-- b + s * (e * k + n') = i
    lw $t6, 0($t5)          # load array element at given address into register $t6

    b get_element_end       # skip printing error message

get_element_invalid_index:
    li $v0, 4               # print error message
    la $a0, get_element_invalid_index_p
    syscall

get_element_end:
    sw $t6, 20($sp)         # return element number at given index
    jr $ra                  # jump back to the main
###########################################################
