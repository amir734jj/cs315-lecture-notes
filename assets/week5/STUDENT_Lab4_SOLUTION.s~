###########################################################
#       Lab 5
#   Name:
#   Date:
#
#   Note:
#       This week's lab is a modification to lab #4. more specifically we use dynamic array
#       instead of static and add one more subprograms
#  
#   Description:
#       Write a subprogram allocate_array that will ask user for an array size and then subprogram
#       allocates a dynamic array of integer with given size. thereafter, subprogram returns base
#       address of array and array size in registers $v0 and $v1 respectively. do not forget to
#       validate array size is greater than zero.
#
#       Write a subprogram print_array that will get as argument IN base address of array and 
#       array size. then it print all array elements separated by a space. in the end, it should
#       print a newline.
#
#   High level design:
#       main:
#           base address, array size <-- allocate_array()
#           store base address and array size into static variables
#
#           sum <-- read_values(base address of array, array size)
#           store sum in static variables "sum_var_p"
#
#           print sum, count and integer average           
#
#
#       allocate_array():
#           while (true) 
#               prompt for number and read number
#
#               if (number <= 0)
#                   print error message
#               else 
#                   use system call 9 to dynamically allocate an array with size == number
#                   return base address and array size in registers $v0, $v1 respectively
#
#           return base address, array size
#
#
#       print_array(base address, array size):
#           for array_element in array:
#               print array_element
#               print "space"
#           
#           print "newline"            
#
#
#       read_values(base address, array size):
#           while (array size > 0):
#               memory[base address] <-- read an odd number from console
#               base address = base address + 4
#               array size = array size - 1
#           
#           return sum
#
###########################################################
#       Register Usage
#   $t0     Holds the returned base address / sum
#   $t1     Holds the returned array size
#   $t3
#   $t4
#   $t5
#   $t6
#   $t7
#   $t8
#   $t9     temporally register
###########################################################
        .data
sum_p:          .asciiz "Sum: "
count_p:        .asciiz "Count: "        
average_p:      .asciiz "Average: "
nextline_p:     .asciiz "\n"

array_pointer_p:.word 0        # holds address of dynamic array (address)
array_size_p:   .word 0        # hold size of dynamic array (value)

sum_var_p:      .word 0        # sum variable initialized to 0
###########################################################
        .text
main:
# calling subprogram allocate_array
                                 
    jal allocate_array          # call read_values subprogram
                                # arguments IN: NONE
                                # arguments OUT: base addresses of integer array, array size

    move $t0, $v0               # copy returned base address into register $t0 
    move $t1, $v1               # copy returned array size into register $t1

    
# store base address and array size into static variables
    la $t9, array_pointer_p     # load address of static variable array_pointer_p into $t9
    sw $t0, 0($t9)              # memory[$t9 + 0] <-- $t0

    la $t9, array_size_p        # load address of static variable array_size_p into $t9
    sw $t1, 0($t9)              # memory[$t9 + 0] <-- $t1


# set up arguments for read_values subprogram
    la $t9, array_pointer_p     # load the address of variable array_pointer into register $t9
    lw $a0, 0($t9)              # fetch the real address of dynamic array into register $a0 
                                # $a0 <-- memory[0 + array_pointer]
    
    la $t9, array_size_p        # load the address of variable array_size into register $t9
    lw $a1, 0($t9)              # fetch the actual value of array size from memory into $a1
                                # $a1 <-- memory[0 + array_size]
                                        
    jal read_values             # call read_values subprogram
                                # arguments IN: base addresses of integer array size = 10
                                # arguments OUT: sum & count

    move $t0, $v0               # copy returned sum into register $t0 


# store sum into static variable
    la $t9, sum_var_p           # load address of static variable sum_p into $t9
    sw $t0, 0($t9)              # memory[$t9 + 0] <-- $t0


# set up arguments for print_array subprogram
    la $t9, array_pointer_p     # load the address of variable array_pointer into register $t9
    lw $a0, 0($t9)              # fetch the real address of dynamic array into register $a0 
                                # $a0 <-- memory[0 + array_pointer]
    
    la $t9, array_size_p        # load the address of variable array_size into register $t9
    lw $a1, 0($t9)              # fetch the actual value of array size from memory into $a1
                                # $a1 <-- memory[0 + array_size]
                                        
    jal print_array             # call read_values subprogram
                                # arguments IN: NONE
                                # arguments OUT: NONE
  
# load sum and array size from static variables
    la $t9, sum_var_p           # load address of static variable sum_p into $t9
    lw $t0, 0($t9)              # $t0 <-- memory[$t9 + 0]

    la $t9, array_size_p        # load the address of variable array_size into register $t9
    lw $t1, 0($t9)              # fetch the actual value of array size from memory into $t1
                                # $t1 <-- memory[0 + array_size]
                                                                   
# copied from solution of Program #1 
    li $v0, 4                   # print newline character
    la $a0, nextline_p
    syscall
    
    li $v0, 4                   # print sum is
    la $a0, sum_p
    syscall

    li $v0, 1                   # print sum integer
    move $a0, $t0
    syscall

    li $v0, 11                  # print newline character
    li $a0, 13
    syscall

    li $v0, 4                   # print count is
    la $a0, count_p
    syscall

    li $v0, 1                   # print count integer
    move $a0, $t1
    syscall

    li $v0, 11                  # print newline character
    li $a0, 13
    syscall

    li $v0, 4                   # print average is
    la $a0, average_p
    syscall

    li $v0, 1                   # print quotient
    div $a0, $t0, $t1           # divide sum by count and put quotient in register $a0
    syscall
                             
mainEnd:
    li $v0, 10
    syscall                     # Halt
###########################################################
#      allocate_array subprogram
#
#   Subprogram description:
#       This subprogram will receive as argument IN two addresses of static variable.
#       Then, it will prompt for array size and validates input to make sure array size
#       is greater than zero ( > 0). Then, it will allocate a dynamic integer array
#       (using system call 9) and store the address of dynamic array and array size
#       into static variables (using provided references). This subprogram does not
#       return anything as argument OUT.
#
###########################################################
#       Arguments IN and OUT of subprogram
#   $a0
#   $a1
#   $a2
#   $a3
#   $v0  Holds base address of dynamic array
#   $v1  Holds array size
#   $sp
#   $sp+4
#   $sp+8
#   $sp+12
###########################################################
#       Register Usage
#   $t0  Holds array pointer (address)
#   $t1  Holds array size pointer (address)
#   $t2  Holds array size, temporarily  
###########################################################
        .data
allocate_array_prompt_p:    .asciiz "Enter size of the array to allocate (size > 0): "
allocate_array_invalid_p:   .asciiz "Array size you entered is incorrect (size > 0)!\n"
###########################################################
        .text
allocate_array:

allocate_array_loop:
    li $v0, 4                   # prompt for array size
    la $a0, allocate_array_prompt_p
    syscall
    
    li $v0, 5                   # reads integer for array size
    syscall
    
    blez $v0, allocate_array_invalid_size   # branch to error section as array size is
                                            # less than or equal to zero
    
    move $t1, $v0               # store valid array size in register $t1
    
    li $v0, 9                   # dynamically allocate an array (using system call 9)
    move $a0, $t1               # puts array size in register $a0
    sll $a0, $a0, 2             # multiply array size by 4, as word in MIPS is 4 bytes
    syscall
    
    move $t0, $v0               # copy base address of array into register $t0
    
    b allocate_array_end        # branch unconditionally to the end of subprogram
    
allocate_array_invalid_size:
    li $v0, 4                   # prints error saying that array size is less than or equal to zero
    la $a0, allocate_array_invalid_p
    syscall
    
    b allocate_array_loop       # branch unconditionally back to beginning of the loop
    
allocate_array_end:
    move $v0, $t0              # return base address of dynamic array in register $v1
    move $v1, $t1              # return size of dynamic array in register $v0

    jr $ra                     # jump back to the main
###########################################################    
#       read_values subprogram
#
#   Subprogram description:
#       Write an assembly sub-program that will receive as argument IN array base address and 
#       array size. then it will read a series of non-negative integers (greater than or equal to zero)
#       that are odd and then add them up to find the sum. it will stop reading values into array until 
#       array is full. finally, subprogram will return sum in register $v0
#
###########################################################
#       Arguments IN and OUT of subprogram
#   $a0     Holds base address of an array
#   $a1
#   $a2
#   $a3
#   $v0     Holds sum
#   $v1
#   $sp
#   $sp+4
#   $sp+8
#   $sp+12
###########################################################
#       Register Usage
#   $t0     Holds sum
#   $t1     Holds base address of an array (that will get incremented by 4 on each iteration)
#   $t2     Holds array size
#   $t3     
#   $t4
#   $t5
#   $t6     
#   $t7     
#   $t8     
#   $t9     Holds constant value 2
###########################################################
        .data
read_values_prompt_p:   .asciiz "Enter a non-negative integer (greater than or equal to zero) that are odd: "
read_values_invalid_p:  .asciiz "Invalid entry. Number should be odd and non-negative.\n"
###########################################################
        .text
read_values:
# load argument IN:
    move $t1, $a0               # load base address of array and put in register $t1
    move $t2, $a1               # load array size and put it in register $t2 
    
    li $t0, 0                   # initialize sum to zero
    li $t9, 2                   # initialize $t9 to constant value 2      
      
read_values_entry_loop:
    blez $t2, read_values_calculation       # branch to calculation if count <= 0

    li $v0, 4                   # prompt for number
    la $a0, read_values_prompt_p
    syscall

    li $v0, 5                   # read integer
    syscall

    bltz  $v0, read_values_invalid_entry    # branch to invalid_entry if value is less than zero
    
    rem $t6, $v0, $t9                       # divide the number by 2 and put entry into register $t6
    beqz $t6, read_values_invalid_entry     # branch to invalid_entry if value is even
    
    add $t0, $t0, $v0                       # add the number to the sum
    
    sw $v0, 0($t1)                          # store the valid number into array
    addi $t1, $t1, 4                        # increment base address of array by 4 because integers
                                            # are 4 bytes and addresses in MIPS are in bytes

    addi $t2, $t2, -1                       # decrement array size by 1

    b read_values_entry_loop                # branch unconditionally to the beginning of the loop

read_values_invalid_entry:
    li $v0, 4                   # print error message
    la $a0, read_values_invalid_p
    syscall

    b read_values_entry_loop    # branch unconditionally to read_values_entry_loop

read_values_calculation:
# return arguments OUT
    move $v0, $t0               # return sum in register $v0

read_values_end:
    jr $ra                      # jump back to the main
###########################################################
#      print_array subprogram
#
#   Subprogram description:
#       This subprogram will receive as argument IN address of integer array and then
#       iterates through array and prints all elements of array. This subprogram
#       does not return anything as argument OUT.
#
###########################################################
#       Arguments IN and OUT of subprogram
#   $a0  Holds array pointer (address)
#   $a1  Holds array size (value)
#   $a2
#   $a3
#   $v0
#   $v1
#   $sp
#   $sp+4
#   $sp+8
#   $sp+12
###########################################################
#       Register Usage
#   $t0  Holds array pointer (address)
#   $t1  Holds array index
###########################################################
        .data
print_array_array_p:    .asciiz     "Array: "
print_array_space_p:    .asciiz     " "
print_array_newline_p:  .asciiz     " " 
###########################################################
        .text
print_array:
# save arguments so we do not lose them
    move $t0, $a0               # move array pointer (address) to $t0
    move $t1, $a1               # move array size (value) to $t1
    
    li $v0, 4                   # prints array is:
    la $a0, print_array_array_p
    syscall
    
print_array_while:
    blez $t1, print_array_end   # branch to print_array_end if counter is less than or equal to zero
    
# print value from array
    li $v0, 1
    lw $a0, 0($t0)              # $a0 <-- memory[$t0 + 0]                    
    syscall                     # load a value from memory to register $a0
    
    li $v0, 4                   # space character
    la $a0, print_array_space_p
    syscall 
    
    addi $t0, $t0, 4            # increment array pointer (address) to next word (each word is 4 bytes)
    addi $t1, $t1, -1           # decrement array counter (index)
    
    b print_array_while         # branch unconditionally back to beginning of the loop
    
print_array_end:
    li $v0, 4                   # prints newline
    la $a0, print_array_newline_p
    syscall
    
    jr $ra                      # jump back to the main
###########################################################
