###########################################################
#       Lab 4 - part (B)
#   Name:
#   Date:
#
#   Note:
#       Take a screenshot of data section of QtSPIM (which would imply that entered values
#       are correctly stored in memory) and submit it to D2L as well.     
#  
#   Description:
#       Write one subprogram beside main (i.e. read_values) and main will call this subprograms:
#       
#       "read_values":
#               Initialize a static array of 10 integers. Then this subprogram reads series of
#               non-negative (greater than or equal to zero) values from the console until -1
#               is entered. If another negative value (i.e. not -1) is entered, then print an
#               error message, reject the negative value, and continue reading entries. If entered
#               value is valid, then add the value to the array and then increment array base
#               address. If index (or pointer) is equal to 10 then stop the loop. In the end,
#               subprogram will return sum and count in registers $v0 and $v1 respectively.
#       
#       "main":
#               From main, call subprogram "read_values" and store returned sum and count in static variables
#               "sum_var_p" and "count_var_p" respectively. Then load values from static variables and 
#               divide sum by count to get average. Then print average. Remember, before dividing sum by
#               count, you (as a programmer) need to check if count is not zero, if count is zero then print
#                zero for average. 
#
#   High level design:
#       main:
#           sum & count <-- read_values(null)
#           store sum & count in static variables "sum_var_p", "count_var_p" respectively
#           reload sum & count from static variables "sum_var_p", "count_var_p" respectively
#           If count is not zero then divide sum by count to get average, otherwise set average to zero
#           print average
#
#       read_values:
#           initialize sum and count to 0
#           initialize static array of size 10
#           initialize index pointer to 0
#
#           while (true) {
#               prompt for number and read number
#
#               if (number == -1) {
#                   break
#               }
#               
#               if (number < 0) {
#                   print error message
#               } 
#                            
#               array[index] = number
#               index = index + 1
#           
#               if (index == 10) {
#                   break
#               }
#
#               sum = sum + number
#               count = count + 1
#           }
#
#           return sum & count in register $v0 and $v1 respectively
#
###########################################################
#       Register Usage
#   $t0     Holds the sum
#   $t1     Holds the count
#   $t3
#   $t4
#   $t5
#   $t6
#   $t7
#   $t8
#   $t9     temporally register
###########################################################
        .data
sum_p:          .asciiz "Sum: "
count_p:        .asciiz "Count: "        
average_p:      .asciiz "Average: "
nextline_p:     .asciiz "\n"
        
sum_var_p:      .word 0                 # sum variable initialized to 0
count_var_p:    .word 0                 # count variable initialized to 0
###########################################################
        .text
main:
# calling subprogram read_values
    jal read_values                     # call read_values subprogram
                                        # arguments IN: NONE
                                        # arguments OUT: sum & count

# move arguments OUT of read_values into temporally registers
    move $t0, $v0                       # move returned sum into register $t0
    move $t1, $v1                       # move returned count into register $t1


# store sum and count into static variables
    la $t9, sum_var_p                   # load address of static variable sum_var_p into register $t9
    sw $t0, 0($t9)                      # store sum value into memory at the address of $t9

    la $t9, count_var_p                 # load address of static variable count_var_p into register $t9
    sw $t1, 0($t9)                      # store count value into memory at the address of $t9

# reload sum and count from static variables
    la $t9, sum_var_p                   # load address of static variable sum_var_p into register $t9
    lw $t0, 0($t9)                      # load sum value from memory at the address of $t9

    la $t9, count_var_p                 # load address of static variable count_var_p into register $t9
    lw $t1, 0($t9)                      # load count value from memory at the address of $t9

    li $v0, 4                           # prints the sum is:
    la $a0, sum_p
    syscall

    li $v0, 1                           # prints the value of sum
    move $a0, $t0
    syscall

    la $a0, nextline_p                  # prints nextline character
    li $v0, 4
    syscall
    
    li $v0, 4                           # prints the count is:
    la $a0, count_p
    syscall

    li $v0, 1                           # prints the value of count
    move $a0, $t1
    syscall

    la $a0, nextline_p                  # prints nextline character
    li $v0, 4
    syscall
        
    li $v0, 4                           # print average is:
    la $a0, average_p
    syscall
    
    bnez $t1, if_count_not_zero         # branch to count_not_zero if count is not zero
                                        # otherwise continue executing the code
    
if_count_zero:
    li $a0, 0                           # put value zero into register $a0 to be printed
    
    b if_end                            # branch unconditionally to the end of if statement to skip
                                        # executing both IF and ELSE block
         
if_count_not_zero:
    div $a0, $t0, $t1                   # divide sum by count to calculate average and put average into $a0
    
if_end:
    li $v0, 1                           # print the value that is in register $a0 using system call 1
    syscall

mainEnd:
    li $v0, 10
    syscall                             # Halt
###########################################################
#       read_values subprogram
#
#   Subprogram description:
#       This subprogram reads series of non-negative (greater than or equal to zero)
#       values from the console until -1 is entered. If another negative value
#       (i.e. not -1) is entered, then print an error message, reject the negative
#       value, and continue reading entries. In the end, subprogram will return sum and
#       count in registers $v0 and $v1 respectively.
#
###########################################################
#       Arguments IN and OUT of subprogram
#   $a0
#   $a1
#   $a2
#   $a3
#   $v0     Holds sum
#   $v1     Holds count
#   $sp
#   $sp+4
#   $sp+8
#   $sp+12
###########################################################
#       Register Usage
#   $t0     Holds the sum
#   $t1     Holds the count
#   $t2     Holds value -1
#   $t3     Holds value 10
#   $t4     Holds base address of static array
###########################################################
        .data
read_values_prompt_p:   .asciiz "Enter a value (-1 to stop): "
read_values_invalid_p:  .asciiz "Invalid entry\n"
read_values_array_p:    .word   0:10    # static array of 10 integers initialized to zero
###########################################################
        .text
read_values:
    li $t0, 0                           # initialize sum of the numbers
    li $t1, 0                           # initialize count of the numbers
    li $t2, -1                          # holds value -1
    li $t3, 10                          # initialize to 10
    la $t4, read_values_array_p         # load base address of static array into register $t4
    
read_values_loop:
    li $v0, 4                           # prompts to enter a value
    la $a0, read_values_prompt_p
    syscall
    
    li $v0, 5                           # gets a value
    syscall
    
    beq $v0, $t2, read_values_exit_loop # branch to the exit_loop if value is -1
    
    bltz $v0, read_values_error         # branch to the error if value if less
                                        # than zero (and not equal to -1 because we 
                                        # had another branch just before this to take
                                        # care of -1 case)
                                        
    beq $t1, $t3, read_values_exit_loop # branch to the exit_loop if count is 10 
    
    sw $v0, 0($t4)                      # store entered number into array
    addiu $t4, $t4, 4                   # increment base address of array by 4
    
    add $t0, $t0, $v0                   # adds the number with total
    addiu $t1, $t1, 1                   # increment the count by one
    
    b read_values_no_error              # branch unconditionally to no_error label to
                                        # skip printing error massage for value >= 0 case
    
read_values_error:
    li $v0, 4                           # prints an error message
    la $a0, read_values_invalid_p
    syscall
    
read_values_no_error:
    b read_values_loop                  # branch unconditionally to the beginning of the loop
    
read_values_exit_loop:
    move $v0, $t0                       # return sum in register $v0
    move $v1, $t1                       # return count in register $v1

read_values_end:
    jr $ra                              # jump back to the main
###########################################################
