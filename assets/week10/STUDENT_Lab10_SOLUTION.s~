###########################################################
#       Lab 10 -  Floating-point
#  
#   Name:
#   Date:
#
#   Description:
#       In main, ask the user for an array length, and then allocate a dynamic array of
#       double-precision floating-point values (each array element is 8 bytes) of the given length
#       Then, store the base address and length of the array in static memory.
#
#       call read_double_array to fill the array
#       call print_double_array to print the array contents
#       call get_sum_avg to get the sum and average
#       print the sum and average
#
#       ask the user for a maximum value
#       call print_less_than to print all values less than the given maximum
#
#   High level design:
#       from main: ask for array length
#       from main: allocate dynamic array of double-precision
#       from main: store array length and array base address in static variable
#       
#       from main call: null <-- subprogram read_double_array(array base address, array length)
#       from main call: null <-- print_double_array(array base address, array length)
#       from main call: sum and average <-- get_sum_avg(array base address, array length)
#
#       from main: ask the user for a maximum value
#       from main call: null <-- print_less_than(array base address, array length, partition value)
#
###########################################################
#       Register Usage
#   $t0  Holds array base address (temporarily)
#   $t1  Holds array length (temporarily)
#   $t2
#   $t3
#   $t4
#   $t5
#   $t6
#   $t7
#   $t8
#   $t9  temporary register
#   $f4|$f5     Holds array sum (double-precision floating-point)
#   $f6|$f7     Holds array average (double precision floating-point)
###########################################################
        .data
array_size_prompt_p:    .asciiz "Enter an array size:  "
sum_p:                  .asciiz "Array sum is:  "
average_p:              .asciiz "Array average is:  "
partition_p:            .asciiz "Enter a partition value:  "

nextline_p:             .asciiz "\n"    # \n

# declare words to hold dynamic array base and array length
array_pointer_p:      .word 0     # holds address dynamic array pointer (address)
array_size_p:         .word 0     # hold size of dynamic array (value)
###########################################################
        .text
main:
# get array length
    li $v0, 4               # prompt for array size
    la $a0, array_size_prompt_p
    syscall
    
    li $v0, 5               # reads integer for array size
    syscall
    
    la $t9, array_size_p
    sw $v0, 0($t9)          # store array length in static variable array_size_p
    
# allocate dynamic array of double-precision floating-point
    sll $a0, $v0, 3         # $a0 <-- $v0 * 2^3
    li $v0, 9
    syscall                 # allocate array using system call 9
    
    la $t9, array_pointer_p
    sw $v0, 0($t9)          # store array base address in static variable array_pointer_p
    

    
# call subprogram to read_double_array
    
# load base and length in static memory
    la $t9, array_pointer_p
    lw $t0, 0($t9)          # load base address
    
    la $t9, array_size_p
    lw $t1, 0($t9)          # load array length 
    
    
    addi $sp, $sp, -4       # allocate one word for $ra
    sw $ra, 0($sp)          # store $ra on stack
    
                            # no register to backup in the stack    
                            
    addi $sp, $sp, -8       # allocate words for the arguments
                            # arguments IN: array base address and array length <-- 2 words
                            # arguments OUT: NONE
                            
    sw $t0, 0($sp)          # store array base address on stack
    sw $t1, 4($sp)          # store array length on stack
    
    jal read_double_array   # jump to subprogram read_double_array
    
    addi $sp, $sp, 8        # deallocate words for the arguments
    
                            # we did not backup a register, so there is no register restoring 
    
    lw $ra, 0($sp)          # load $ra from stack
    addi $sp, $sp, 4        # deallocate word for $ra


    
# call subprogram to print_double_array
    la $t9, array_pointer_p
    lw $t0, 0($t9)          # load base address
    
    la $t9, array_size_p
    lw $t1, 0($t9)          # load array length 
    
    addi $sp, $sp, -4       # allocate one word for $ra
    sw $ra, 0($sp)          # store $ra on stack
    
                            # no register to backup in the stack
                            
    addi $sp, $sp, -8       # allocate words for the arguments
                            # arguments IN: array base address and array length <-- 2 words
                            # arguments OUT: NONE
                            
    sw $t0, 0($sp)          # store array base address on stack
    sw $t1, 4($sp)          # store array length on stack
    
    jal print_double_array  # jump to subprogram print_double_array
    
    addi $sp, $sp, 8        # deallocate words for the arguments
    
                            # we did not backup a register, so there is no register restoring
                            
    lw $ra, 0($sp)          # load $ra from stack
    addi $sp, $sp, 4        # deallocate word for $ra
    
    
    
# call subprogram get_sum_avg
    la $t9, array_pointer_p
    lw $t0, 0($t9)          # load base address
    
    la $t9, array_size_p
    lw $t1, 0($t9)          # load array length 
    
    addi $sp, $sp, -4       # allocate one word for $ra
    sw $ra, 0($sp)          # store $ra on stack
    
                            # no register to backup in the stack
                            
    addi $sp, $sp, -24      # allocate words for the arguments 4 arguments (8 bytes + 16 bytes = 24 bytes)
                            # arguments IN: array base address and array length <-- 2 words: 2 * 4 = 8 bytes
                            # arguments OUT: array sum and array average        <-- 2 double-precision floating-point: 2 * 8 = 16 bytes 
    
    sw $t0, 0($sp)          # store array base on stack
    sw $t1, 4($sp)          # store array length on stack
    
    jal get_sum_avg         # jump to subprogram get_sum_avg
    
    l.d $f4, 8($sp)         # load double-precision floating-point number of sum from stack into register $f4
    l.d $f6, 16($sp)        # load double-precision floating-point number of average from stack into register $f6
    addi $sp, $sp, 24       # deallocate words for the arguments
    
                            # we did not backup a register, so there is no register restoring
                            
    lw $ra, 0($sp)          # load $ra from stack
    addi $sp, $sp, 4        # deallocate word for $ra
    

    la $a0, nextline_p      # prints nextline character
    li $v0, 4
    syscall     
    
    
# print sum and average
    li $v0, 4               # prints array sum is:
    la $a0, sum_p
    syscall
    
    li $v0, 3               # print double-precision floating-point number of sum using system call 3
    mov.d $f12, $f4         # move double-precision floating-point number from $f4 into register $f12
    syscall

    la $a0, nextline_p      # prints nextline character
    li $v0, 4
    syscall     
    
    li $v0, 4               # prints array average is:
    la $a0, average_p
    syscall
    
    li $v0, 3               # print double-precision floating-point number of average using system call 3
    mov.d $f12, $f6         # move double-precision floating-point number from $f6 into register $f12
    syscall
    
    
    la $a0, nextline_p      # prints nextline character
    li $v0, 4
    syscall     
    
# call subprogram print_less_than
    li $v0, 4               # prompt for partition  value
    la $a0, partition_p
    syscall
    
    li $v0, 7               # read partition value which is in double-precision floating-point using system call 7
    syscall
    
# entered value is in $f0     
    la $t9, array_pointer_p
    lw $t0, 0($t9)          # load base address
    
    la $t9, array_size_p
    lw $t1, 0($t9)          # load array length 
    
    addi $sp, $sp, -4       # allocate one word for $ra
    sw $ra, 0($sp)          # store $ra on stack
    
                            # no register to backup in the stack
                            
    addi $sp, $sp, -16      # allocate words for the arguments 4 arguments (8 bytes + 8 bytes = 16 bytes)
                            # arguments IN: array base address, array length and partition value <-- 2 * 4 bytes + 1 * 8 bytes = 16 bytes
                            # arguments OUT: NONE

    sw $t0, 0($sp)          # store array base on stack
    sw $t1, 4($sp)          # store array length on stack
    s.d $f0, 8($sp)         # store partition value
    
    jal print_less_than     # jump to subprogram print_less_than
    
    addi $sp, $sp, 16       # deallocate words for the arguments
    
                            # we did not backup a register, so there is no register restoring
                            
    lw $ra, 0($sp)          # load $ra from stack
    addi $sp, $sp, 4        # deallocate word for $ra

mainEnd:
    li $v0, 10
    syscall                 # Halt
###########################################################
#       read_double_array subprogram
#
#   Subprogram description:
#       Reads double-precision floating-point numbers into an array,
#       printing a prompt before reading each double
#
###########################################################
#       Arguments IN and OUT of subprogram
#   $sp+0   Holds array base address (IN)
#   $sp+4   Holds array length (IN)
###########################################################
#       Register Usage
#   $t0         Holds array index address
#   $t1         Holds array length/loop countdown
#   $f0|$f1     Holds array entry
###########################################################
        .data
read_double_array_prompt_p:      .asciiz "Enter a real number:  "
###########################################################
        .text
read_double_array:
# save arguments so we do not lose them
    lw $t0, 0($sp)          # load array base address
    lw $t1, 4($sp)          # load array length
    
read_double_array_loop:
    blez $t1, read_double_array_end # while($t1 > 0)
    
    li $v0, 4               # prompt and read a number
    la $a0, read_double_array_prompt_p
    syscall
    
    li $v0, 7               # read double-precision floating-point number
    syscall
    
    s.d $f0, 0($t0)         # read double-precision floating-point number
    
    addi $t0, $t0, 8        # increment array pointer (address) to next two words (each double-precision floating-point number is 8 bytes)
    addi $t1, $t1, -1       # decrement array counter (index)
    
    b read_double_array_loop    # branch unconditionally back to beginning of the loop
    
read_double_array_end:
    jr $ra                  # jump back to the main
###########################################################
#       print_double_array subprogram
#
#   Subprogram description:
#       Print array of double-precision floating-point numbers
#
###########################################################
#       Arguments IN and OUT of subprogram
#   $sp+0   Holds array base address (IN)
#   $sp+4   Holds array length (IN)
###########################################################
#       Register Usage
#   $t0         Holds array index address
#   $t1         Holds array length/loop countdown
#   $f12|$f13   Holds array value
###########################################################
        .data
print_double_array_prompt_p:   .asciiz     "Array: "
print_double_array_space_p:    .asciiz     " "      
###########################################################
        .text
print_double_array:
# save arguments so we do not lose them
    lw $t0, 0($sp)          # load array base address
    lw $t1, 4($sp)          # load array length

    li $v0, 4               # prints array is:
    la $a0, print_double_array_prompt_p
    syscall
    
print_double_array_loop:
    blez $t1, print_double_array_end    # while($t1 > 0)
    
    l.d $f12, 0($t0)        # load array value into register $f12
    
    li $v0, 3               # print double-precision floating-point number using system call 3
    syscall
    
    li $v0, 4               # space character
    la $a0, print_double_array_space_p
    syscall 
    
    addi $t0, $t0, 8        # increment array pointer (address) to next two words (each double-precision floating-point number is 8 bytes)
    addi $t1, $t1, -1       # decrement array counter (index)
    
    b print_double_array_loop   # branch unconditionally back to beginning of the loop

print_double_array_end:
    jr $ra                  # jump back to the main
###########################################################
#       get_sum_avg subprogram
#
#   Subprogram description:
#       Calculate sum and average of an array of doubles
#       If the number of elements is 0, print an error and return 0.0 for both sum and average
#
#       Remember, to calculate average we need to divide sum (:: double) / (:: integer)
#       But there is no type promotion (or widening primitive conversion)in MIPS, which mean as a programmer we have to
#       implicitly convert count to double before being able to sum by count.
#
###########################################################
#       Arguments IN and OUT of subprogram
#   $sp+0   Holds array base address (IN)
#   $sp+4   Holds array length (IN)
#   $sp+8   Holds array sum {double precision floating-point number} (OUT)
#   $sp+16  Holds array average {double precision floating-point number} (OUT)
###########################################################
#       Register Usage
#   $t0         Holds array index address
#   $t1         Holds array length/loop countdown
#   $t2         Holds loop countdown
#   $f4|$f5     Holds array Sum
#   $f6|$f7     Holds array Average
#   $f8|$f9     Holds array value/Count
###########################################################
        .data
get_sum_avg_invalid_count_p:     .asciiz "Invalid count, cannot calculate average\n"
###########################################################
        .text
get_sum_avg:
# save arguments so we do not lose them
    lw $t0, 0($sp)          # load array base address
    lw $t1, 4($sp)          # load array length
    
    li.d $f4, 0.0           # initialize sum to zero
    li.d $f6, 0.0           # initialize average to zero
    
    move $t2, $t1           # copy length into $t2 so we do not lose it
    
    
    bgtz $t1, get_sum_avg_valid_count    # if($t1 <= 0) then print error message and return 0.0 for both sum and average
    
    li $v0, 4               # print invalid count error message
    la $a0, get_sum_avg_invalid_count_p
    syscall
    
    b get_sum_avg_end       # branch unconditionally to the end of subprogram
    
    
get_sum_avg_valid_count:

get_sum_avg_loop:
    blez $t2, get_sum_avg_loop_end  # while($t2 > 0)
    
    l.d $f8, 0($t0)         # load array value
    add.d $f4, $f4, $f8     # add the number with the sum and put the result back to the sum
    
    addi $t0, $t0, 8        # increment array pointer (address) to next two words (each double-precision floating-point number is 8 bytes)
    addi $t2, $t2, -1       # decrement array counter (index)
    
    b get_sum_avg_loop      # branch unconditionally back to beginning of the loop
    
    
get_sum_avg_loop_end:
    mtc1 $t1, $f8           # move to co-processor 1 from $t1
    cvt.d.w $f8, $f8        # convert count to double
    div.d $f6, $f4, $f8     # $f6|$f7 <-- $f4|$f5 / $f8|$f9


get_sum_avg_end:
    s.d $f4, 8($sp)         # return sum
    s.d $f6, 16($sp)        # return average
    
    jr $ra                  # jump back to the main
###########################################################
#       print_less_than subprogram
#
#   Subprogram description:
#       Prints all values from the array which are less
#       than the given maximum
#
###########################################################
#       Arguments IN and OUT of subprogram
#   $sp+0   Holds array base address (IN)
#   $sp+4   Holds array length (IN)
#   $sp+8   Holds maximum value {double precision floating-point number} (IN)
###########################################################
#       Register Usage
#   $t0         Holds array index address
#   $t1         Holds array length/Loop countdown
#   $f4|$f5     Holds partition value
#   $f12|$f13   Holds array value (array element at any particular index)
###########################################################
        .data
print_less_than_prompt_p:   .asciiz     "Array values less than partition value are: "      
print_less_than_space_p:    .asciiz     " "             
###########################################################
        .text
print_less_than:
# save arguments so we do not lose them
    lw $t0, 0($sp)          # load array base address
    lw $t1, 4($sp)          # load array length
    
    l.d $f4, 8($sp)         # load partition value

    li $v0, 4               # prints array is:
    la $a0, print_less_than_prompt_p
    syscall
    
print_less_than_loop:
    blez $t1, print_less_than_end   # while($t1 > 0)
    
    l.d $f12, 0($t0)        # load value from array
    
    c.lt.d $f12, $f4        # compare and set flag if $f12 < $f4
    bc1f print_less_than_else       # if($f12 < $f4 == false) then
                                    #   do not print anything
                                    # else
                                    #   print array value
    
print_less_than_if:
    li $v0, 3               # print array value using system call 3. The number that is going to be printed
    syscall                 # is already in registers $f12

	
    li $v0, 4               # space character
    la $a0, print_less_than_space_p
    syscall 
    
print_less_than_else:
# print nothing, do not print anything, or simply skip printing
    
    addi $t0, $t0, 8        # increment array pointer (address) to next two words (each double-precision floating-point number is 8 bytes)
    addi $t1, $t1, -1       # decrement array counter (index)
    
    b print_less_than_loop  # branch unconditionally back to beginning of the loop
    
print_less_than_end:
    jr $ra                  # jump back to the main
###########################################################
