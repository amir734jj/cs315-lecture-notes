###########################################################
#       Lab 13 - data structures, modification
#
#   Name:
#   Date:
#
#   Description:
#       1. call create_array to create an array of data structures
#       2. call print_table to print a table of the data structures
#       3. call get_stats to get information about all data structures in the array
#
#   Difference of lab #12 and #13:
#       in this lab, we change integer to single precision floating point and we introduce string 
#       of character array into data structure. 
#
#   High level design:
#       from main call: <-- array base address, array size <-- create_array()
#           from create_array call: null <-- read_array(array base address, array size)
#           
#       from main call: null <-- print_table(array base address, array size)
#
#       from main call: array sum, array average <-- get_stats(array base address, array size)
#
#       from main: print array sum
#       from main: print array average
#
#   Data structure (total size = 8 + 4 + 20 = 32 = 2^5):
#       offset 0 --> double-precision value
#       offset 8 --> single precision value
#       offset 12--> array of characters or integers, size of array = 20 bytes
#
#   Design:
#       [
#           [1.5   1.1     'A', B', 'C', '\0'],
#           [2.5   2.1     'D', E', 'F', '\0']
#       ]
#   
#   Formula:
#       sum = (1.5 * 1.1) + (2.5 * 2.1)  = 6.9
#       average = (1.5 * 1.1) + (2.5 * 2.1) / 2 = 3.45
#       
###########################################################
        .data
average_p:      .asciiz "Average: "
total_p:        .asciiz "Total: "

# declare words to hold dynamic array base and array size
array_pointer_p:      .word 0   # holds address dynamic array pointer (address)
array_size_p:         .word 0   # hold size of dynamic array (value)
###########################################################
        .text
main:
# calling a subprogram create_array to dynamically allocate data structure
    addi $sp, $sp, -4           # allocate one word for $ra
    sw $ra, 0($sp)              # store $ra on stack

                                # no register to backup in the stack
                            
    addi $sp, $sp, -8           # allocate words for the arguments
                                # arguments IN: NONE
                                # arguments OUT: array base address, array size <-- 2 words
                                
    jal create_array            # call subprogram create_array
    
    lw $t0, 0($sp)              # read array base address from stack
    lw $t1, 4($sp)              # read array size from stack
    addi $sp, $sp, 8            # deallocate words for the arguments
    
                                # we did not backup a register, so there is no register restoring 
    
    lw $ra, 0($sp)              # load $ra from stack
    addi $sp, $sp, 4            # deallocate word for $ra


    
# store array base address and array size into static variables
    la $t9, array_pointer_p     # store array base address into static variable
    sw $t0, 0($t9)

    la $t9, array_size_p        # store array base size into static variable
    sw $t1, 0($t9)


# calling a subprogram print_table to print the data structures

# restore array base address and array size from static variables
    la $t9, array_pointer_p     # store array base address into static variable
    lw $t0, 0($t9)

    la $t9, array_size_p        # store array base size into static variable
    lw $t1, 0($t9)  
    
    addi $sp, $sp, -4           # allocate one word for $ra
    sw $ra, 0($sp)              # store $ra on stack

                                # no register to backup in the stack
                            
    addi $sp, $sp, -8           # allocate words for the arguments
                                # arguments IN: array base address, array size  <-- 2 words
                                # arguments OUT: NONE
                                    
    sw $t0, 0($sp)              # store array base address on stack
    sw $t1, 4($sp)              # store array size on stack

    jal print_table             # call subprogram print_table

    addi $sp, $sp, 8            # deallocate words for the arguments
    
                                # we did not backup a register, so there is no register restoring 
    
    lw $ra, 0($sp)              # load $ra from stack
    addi $sp, $sp, 4            # deallocate word for $ra
    
    
    
# calling a subprogram get_stats to get statistics about the data structures (sum and average)

# restore array base address and array size from static variables
    la $t9, array_pointer_p     # store array base address into static variable
    lw $t0, 0($t9)
    la $t9, array_size_p        # store array base size into static variable
    lw $t1, 0($t9)  
    
    addi $sp, $sp, -4           # allocate one word for $ra
    sw $ra, 0($sp)              # store $ra on stack

                                # no register to backup in the stack
                            
    addi $sp, $sp, -24          # allocate words for the arguments
                                #   2 arguments IN:     array base address, array size
                                #   2 arguments OUT:    array sum and array average
                                
    sw $t0, 0($sp)              # store array base address on stack
    sw $t1, 4($sp)              # store array size on stack

    jal get_stats               # call subprogram get_stats

    l.d $f0, 8($sp)             # load array sum from stack
    l.d $f2, 16($sp)            # load array average from stack
    
    addi $sp, $sp, 24           # deallocate words for the arguments
    
                                # we did not backup a register, so there is no register restoring 
    
    lw $ra, 0($sp)              # load $ra from stack
    addi $sp, $sp, 4            # deallocate word for $ra


# print array sum and array average 

# print new line character  
    li $a0, 10                  # print new line character (ASCII code 10)
    li $v0, 11
    syscall 
    
    li $v0, 4                   # array sum is:
    la $a0, total_p
    syscall
    
    li $v0, 3                   # print array sum value
    mov.d $f12, $f0
    syscall

# print new line character  
    li $a0, 10                  # print new line character (ASCII code 10)
    li $v0, 11
    syscall 
    
    li $v0, 4                   # array average is:
    la $a0, average_p
    syscall
    
    li $v0, 3                   # print array average value
    mov.d $f12, $f2
    syscall
    
mainEnd:
    li $v0, 10
    syscall                     # Halt
###########################################################
#       create_array subprogram
#
#   Subprogram description:
#       1) ask the user for an array length
#       2) call read_array to fill the array
#   
#           - use offset 0 to store double precision
#           - use offset 8 to store single precision
#           - use offset 12 as a base address for character array of 20 bytes
#
#       therefore, each structure requires 8 + 4 + 20 = 32 = 2^5 bytes
#
#  Example:
#    data structure:
#       [
#           [1.5   1.1     'A', B', 'C', '\0'],
#           [2.5   2.1     'D', E', 'F', '\0']
#       ]
#
###########################################################
#       Arguments IN and OUT of subprogram
#   $sp+0   Holds array base address (OUT)
#   $sp+4   Holds array length (OUT)
###########################################################
#       Register Usage
#   $t0     Holds array index address
#   $t1     Holds array length/loop countdown
#   $t2     constant value 12
###########################################################
        .data
create_array_length_p:  .asciiz "Enter an array length (or data structure size):  "
create_array_invalid_p: .asciiz "Invalid length\n"
###########################################################
        .text
create_array:

create_array_loop:
    li $v0, 4                   # prompt for array size
    la $a0, create_array_length_p
    syscall
    
    li $v0, 5                   # read array size (integer)
    syscall
    
# check for valid array size > 0
    bgtz $v0, create_array_valid_size       # if array size is greater than zero, then branch to valid_size
    
create_array_invalid_size:
    li $v0, 4                   # print invalid array size error message
    la $a0, create_array_invalid_p
    syscall
            
    b create_array_loop         # branch unconditionally to the prompt
    
create_array_valid_size:
    sw $v0, 4($sp)              # store array size in 4($sp)
    move $t1, $v0               # copy array size into register $t1

    li $v0, 9                   # use system call 9 to allocate space for data structure    
    sll $a0, $v0, 5             # each structure is 32 bytes or 2^5
    syscall
    
    sw $v0, 0($sp)              # store array base address in 0($sp)
    move $t0, $v0               # copy array base address into register $t0

# print new line character  
    li $a0, 10                  # print new line character (ASCII code 10)
    li $v0, 11
    syscall
    
# calling a subprogram read_array to read values into data structure
    addi $sp, $sp, -4           # allocate one word for $ra
    sw $ra, 0($sp)              # store $ra on stack

                                # no register to backup in the stack
                            
    addi $sp, $sp, -8           # allocate words for the arguments
                                # arguments IN: array base address, array size  <-- 2 words
                                # arguments OUT: NONE
                                
    sw $t0, 0($sp)              # store array base address on stack
    sw $t1, 4($sp)              # store array size address on stack 
    jal read_array              # call subprogram read_array

    addi $sp, $sp, 8            # deallocate words for the arguments
    
                                # we did not backup a register, so there is no register restoring 
    
    lw $ra, 0($sp)              # load $ra from stack
    addi $sp, $sp, 4            # deallocate word for $ra   
    
create_array_end:   
    jr $ra                      # jump back to the main
###########################################################
#       read_array subprogram
#
#   Subprogram description:
#       1) reads data structures into the array until the array is full
#       2) store double, float and character array at the correct offsets
#
#           - use offset 0 to store double precision
#           - use offset 8 to store single precision
#           - use offset 12 as a base address for character array of 20 bytes
#
#  Example:
#    data structure:
#       [
#           [1.5   1.1     'A', B', 'C', '\0'],
#           [2.5   2.1     'D', E', 'F', '\0']
#       ]
#
###########################################################
#       Arguments IN and OUT of subprogram
#   $sp+0   Holds array base address (IN)
#   $sp+4   Holds array length (IN)
###########################################################
#       Register Usage
#   $t0     Holds array index address
#   $t1     Holds array length/loop countdown
###########################################################
        .data
read_array_float_p:    .asciiz "Enter an float: "
read_array_double_p:   .asciiz "Enter a double: "
read_array_string_p:   .asciiz "Enter a string: "
###########################################################
        .text
read_array:
# save arguments so we do not lose them
    lw $t0, 0($sp)              # load array base address
    lw $t1, 4($sp)              # load array length
    
read_array_loop:
    blez $t1, read_array_end    # while($t1 > 0)

    li $v0, 4                   # prompt for double value
    la $a0, read_array_double_p
    syscall
    
    li $v0, 7                   # read double value
    syscall 
    s.d $f0, 0($t0)             # store double value at offset 0($t0)   


    li $v0, 4                   # prompt for integer value
    la $a0, read_array_float_p
    syscall
    
    li $v0, 6                   # read float value
    syscall
    s.s $f0, 8($t0)             # store integer value at offset 8($t0)
    
 
    li $v0, 4                   # prompt for string value (or character array)
    la $a0, read_array_string_p
    syscall
       
    li $v0, 8                   # read string using system call 8
    addi $a0, $t0, 12           # set $t0 + 12 as a base address of buffer
    li $a1, 20                  # set buffer size to 20 characters max
    syscall
    
    addiu $t0, $t0, 32          # increment array base address
    addiu $t1, $t1, -1          # decrement array size / countdown

# print new line character  
    li $a0, 10                  # print new line character (ASCII code 10)
    li $v0, 11
    syscall
    
    b read_array_loop           # branch unconditionally back to beginning of the loop
    
read_array_end:
    jr $ra                      # jump back to the main
###########################################################
#       print_table subprogram
#
#   Subprogram description:
#       1) prints all data structures in the array
#       2) prints the doubles followed by the float and then string, separated by four spaces (or tab character)
#
#           - use offset 0 to store double precision
#           - use offset 8 to store single precision
#           - use offset 12 as a base address for character array of 20 bytes
#
#  Example:
#    data structure:
#       [
#           [1.5   1.1     'A', B', 'C', '\0'],
#           [2.5   2.1     'D', E', 'F', '\0']
#       ]
#
#   Note:
#       ASCII code 9 is a horizontal tab.
#       ASCII code 10 is a newline character.
#       system call to print a character is: 11
#
#   Example:
#       1.5    1.1  ABC
#       2.5    2.1  DEF
#
###########################################################
#       Arguments IN and OUT of subprogram
#   $sp+0   Holds array base address (IN)
#   $sp+4   Holds array length (IN)
###########################################################
#       Register Usage
#   $t0     Holds array index address
#   $t1     Holds array length/loop countdown
###########################################################
        .data
print_table_structs_p:  .asciiz "Data table:\n"
###########################################################
        .text
print_table:
# save arguments so we do not lose them
    lw $t0, 0($sp)              # load array base address
    lw $t1, 4($sp)              # load array length

    li $v0, 4                   # print Data table is:
    la $a0, print_table_structs_p
    syscall
    
print_table_loop:
    blez $t1, print_table_end   # while($t1 > 0)
    
    li $v0, 3                   # print double value using system call 3
    l.d $f12, 0($t0)            # load double value form 0($t0)
    syscall
    
    li $v0, 11                  # print horizontal tab character (ASCII code 9)
    li $a0, 9
    syscall
    
    li $v0, 2                   # print float value using system call 2
    l.s $f12, 8($t0)            # load double value form 8($t0)
    syscall
    
    li $v0, 11                  # print horizontal tab character (ASCII code 9)
    li $a0, 9
    syscall
    
    li $v0, 4                   # print string using system call 4
    addi $a0, $t0, 12           # $a0 <-- $t0 + 12  // base address of character array
    syscall
    
    li $a0, 10                  # print new line character (ASCII code 10)
    li $v0, 11
    syscall
    
    addiu $t0, $t0, 32          # increment array base address
    addiu $t1, $t1, -1          # decrement array size / countdown
    
    b print_table_loop          # branch unconditionally back to beginning of the loop
    
print_table_end:
    jr $ra                      # jump back to the main
###########################################################
#       get_stats subprogram
#
#   Subprogram description:
#       1) calculates average and total value of array
#       2) average is the sum of all doubles divided by the number of elements in the array
#       3) total is the sum of all doubles, each multiplied by integer in the same data structure
#
#   Example:
#       [
#           [1.5   1.1     'A', B', 'C', '\0'],
#           [2.5   2.1     'D', E', 'F', '\0']
#       ]
#   
#   Formula:
#       sum = (1.5 * 1.1) + (2.5 * 2.1)  = 6.9
#       average = (1.5 * 1.1) + (2.5 * 2.1) / 2 = 3.45
#
###########################################################
#       Arguments IN and OUT of subprogram
#   $sp+0   Holds array base address (IN)
#   $sp+4   Holds array length (IN)
#   $sp+8   Holds sum value of array (OUT)
#   $sp+16  Holds average value of all doubles (OUT)
###########################################################
#       Register Usage
#   $t0     Holds array index address
#   $t1     Holds array length/loop countdown
#   $t2     Holds Integer from structure
#   $f4|$f5 Holds array sum (double * integer)
#   $f6|$f7 Holds array average (double * integer) / count
#   $f8|$f9 Holds array size in double
#   $f10|$f11   Holds array value / TEMP
#   $f12|$f13   TEMP
###########################################################
        .data
###########################################################
        .text
get_stats:
# save arguments so we do not lose them
    lw $t0, 0($sp)              # load array base address
    lw $t1, 4($sp)              # load array length
    
    li.d $f4, 0.0               # initialize sum
    li.d $f6, 0.0               # initialize average
    
    mtc1 $t1, $f8               # convert array size from integer to double
    cvt.d.w $f8, $f8            # store array size (double) into register $f8
    
get_stats_loop:
    blez $t1, get_stats_end     # while ($t1 > 0)
    
    l.d $f10, 0($t0)            # load double value from 0($t0)
    l.s $f12, 8($t0)              # load integer value from 8($t0)
    
    cvt.d.s $f12, $f12          # convert float to double and store it in $f12

    mul.d $f10, $f10, $f12      # multiply double by integer (formerly)
    
    add.d $f4, $f4, $f10        # sum <-- sum  + multiply double by integer (formerly)
    
    addiu $t0, $t0, 32          # increment array base address
    addiu $t1, $t1, -1          # decrement array size / countdown
    
    b get_stats_loop            # branch unconditionally back to beginning of the loop
    
get_stats_end:
    div.d $f6, $f4, $f8         # divide array sum (double) by array size (double) and put it in register $f6
    
    s.d $f4, 8($sp)             # return array sum
    s.d $f6, 16($sp)            # return array average
    
    jr $ra                      # jump back to the main
###########################################################
