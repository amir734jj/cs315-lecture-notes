###########################################################
#       Lab 8 - Recursive subprograms (or many levels deep function calls)
#   Name:
#   Date:
#
#   Objective:
#       Learning recursive design in assembly by implementing Fibonacci series.
#
#   Description:
#       Main will initialize registers $t0 and $t1 to 0 and 10 respectively
#       and for all values in range 0...10, it will call subprogram fibonacci($t0).
#
#   Note:
#       Implement the main and fibonacci subprogram, then run the code to print
#       Fibonacci series of 10 elements. Checkout with your TA.
#
#   High-level design:
#       main:
#           $t0 <-- counter (initialize to 0)
#           $t1 <-- number of terms in series (initialize to 10)
#
#           while ($t0 < $t1) {
#               print fibonacci($t0)
#
#               $t0 <-- $t0 + 1
#           }
#
#           halt
#
#   Sample run:
#       Fibonacci series using recursion (modify $t1 to change number of terms): 0, 1, 2, 3, 5, 8, 13, 21, 34, 55, 
#
###########################################################
#       Register Usage
#   $t0  Holds value 0 (initialized to zero)
#   $t1  Holds constant value 10
###########################################################
        .data
prompt_p:   .asciiz "Fibonacci series using recursion (modify $t1 to change number of terms): "
space_p:    .asciiz ", "
###########################################################
        .text
main:
    li $t0, 0               # initialize counter to 0
    li $t1, 10              # initialize number of terms to 10

    li $v0, 4               # print Fibonacci series is:
    la $a0, prompt_p
    syscall

loop:
    bge $t0, $t1, mainEnd   # if counter == 10 the branch to mainEnd

# call: result <-- fibonacci($t0) and print result
    addiu $sp, $sp, -4      # allocate 4 bytes for $ra
    sw $ra, 0($sp)          # backup $ra on the stack (memory[$sp + 0] <-- $ra)

    addiu $sp, $sp, -8      # allocate 8 bytes for backup registers (i.e. $t0, $t1)
    sw $t0, 0($sp)          # backup $t0 on the stack (memory[$sp + 0] <-- $t0)
    sw $t1, 4($sp)          # backup $t1 on the stack (memory[$sp + 4] <-- $t1)

    addiu $sp, $sp, -8      # allocate 8 bytes for arguments IN and OUT
    sw $t0, 0($sp)          # store argument IN on the stack (memory[$sp + 0] <-- $t0)

    jal fibonacci           # call subprogram fibonacci

    li $v0, 1               # print integer via system call 1
    lw $a0, 4($sp)          # load argument OUT from stack ($a0 <-- memory[$sp + 4])
    syscall

    li $v0, 4               # print space
    la $a0, space_p
    syscall

    addiu $sp, $sp, 8       # deallocate 8 bytes for argument IN and OUT

    lw $t0, 0($sp)          # restore backup register $t0 from stack ($t0 <-- memory[$sp + 0])
    lw $t1, 4($sp)          # restore backup register $t1 from stack ($t1 <-- memory[$sp + 4])
    addiu $sp, $sp, 8       # deallocate space for backup registers

    lw $ra, 0($sp)          # restore $ra from stack ($ra <-- memory[$sp + 0])
    addiu $sp, $sp, 4       # deallocate space for $ra

    addi $t0, $t0, 1        # increment counter by 1

    b loop                  # branch unconditionally back to beginning of the loop

mainEnd:
    li $v0, 10              # halt
    syscall
###########################################################
#        fibonacci subprogram
#
#   subprogram description:
#       this subprogram receives as argument IN an integer value and if
#       the integer is less than or equal to 2 then it returns the value in $sp + 4.
#       otherwise, it recursively calls a = fibonacci(value - 1) and
#       b = fibonacci(value - 2) and subprogram returns a + b
#
#   Algorithm:
#       fibonacci(int value) {
#           if(value <= 2) {
#               return value;
#           }
#
#           return fibonacci(value - 1) + fibonacci(value - 2);
#       }
#
###########################################################
#       Arguments IN and OUT of subprogram
#   $a0
#   $a1
#   $a2
#   $a3
#   $v0
#   $v1
#   $sp     # Holds argument IN (input value)
#   $sp+4   # Holds argument OUT or fibonacci(value)
#   $sp+8
#   $sp+12
###########################################################
#       Register Usage
#   $t0  Holds value (or the term number)
#   $t1  Holds constant value 2
#   $t2  Holds fibonacci(value - 1)
#   $t3  Holds fibonacci(value - 2)
#   $t4
#   $t5
#   $t6
#   $t7
#   $t8
#   $t9  temporarily
###########################################################
        .data
###########################################################
        .text
fibonacci:
# load argument IN which is the value
    lw $t0, 0($sp)         # $t0 <-- memory[$sp + 0]
    li $t1, 2              # $t1 <-- constant value 2

    bgt $t0, $t1, fibonacci_return # if $t0 > $t1 then branch to fibonacci_return
    move $t9, $t0                  # else copy content of register $t0 into $t9

    b fibonacci_end                # branch to fibonacci_end which return $t9 as argument OUT

fibonacci_return:
# calculating fibonacci($t0 - 1)
    addiu $sp, $sp, -4      # allocate 4 bytes for $ra
    sw $ra, 0($sp)          # backup $ra on the stack (memory[$sp + 0] <-- $ra)

    addiu $sp, $sp, -8      # allocate 8 bytes for backup registers (i.e. $t0, $t1)
    sw $t0, 0($sp)          # backup $t0 on the stack (memory[$sp + 0] <-- $t0)
    sw $t1, 4($sp)          # backup $t1 on the stack (memory[$sp + 4] <-- $t1)

    addiu $sp, $sp, -8      # allocate 8 bytes for arguments IN and OUT
    addiu $t9, $t0, -1      # $t9 <-- $t0 - 1
    sw $t9, 0($sp)          # store argument IN on the stack (memory[$sp + 0] <-- $t9)

    jal fibonacci           # call subprogram fibonacci (recursive)

    lw $t2, 4($sp)          # load argument OUT from stack ($t2 <-- memory[$sp + 4])
    addiu $sp, $sp, 8       # deallocate 8 bytes for argument IN and OUT

    lw $t0, 0($sp)          # restore backup register $t0 from stack ($t0 <-- memory[$sp + 0])
    lw $t1, 4($sp)          # restore backup register $t1 from stack ($t1 <-- memory[$sp + 4])
    addiu $sp, $sp, 8       # deallocate space for backup registers

    lw $ra, 0($sp)          # restore $ra from stack ($ra <-- memory[$sp + 0])
    addiu $sp, $sp, 4       # deallocate space for $ra


# calculating fibonacci($t0 - 2)
    addiu $sp, $sp, -4      # allocate 4 bytes for $ra
    sw $ra, 0($sp)          # backup $ra on the stack (memory[$sp + 0] <-- $ra)

    addiu $sp, $sp, -12     # allocate 12 bytes for backup registers (i.e. $t0, $t1, $t2)
    sw $t0, 0($sp)          # backup $t0 on the stack (memory[$sp + 0] <-- $t0)
    sw $t1, 4($sp)          # backup $t1 on the stack (memory[$sp + 4] <-- $t1)
    sw $t2, 8($sp)          # backup $t2 on the stack (memory[$sp + 8] <-- $t2)

    addiu $sp, $sp, -8      # allocate 8 bytes for arguments IN and OUT
    addiu $t9, $t0, -2      # $t9 <-- $t0 - 2
    sw $t9, 0($sp)          # store argument IN on the stack (memory[$sp + 0] <-- $t9)

    jal fibonacci           # call subprogram fibonacci (recursive)

    lw $t3, 4($sp)          # load argument OUT from stack ($t3 <-- memory[$sp + 4])
    addiu $sp, $sp, 8       # deallocate 8 bytes for argument IN and OUT

    lw $t0, 0($sp)          # restore backup register $t0 from stack ($t0 <-- memory[$sp + 0])
    lw $t1, 4($sp)          # restore backup register $t1 from stack ($t1 <-- memory[$sp + 4])
    lw $t2, 8($sp)          # restore backup register $t2 from stack ($t2 <-- memory[$sp + 8])
    addiu $sp, $sp, 12      # deallocate space for backup registers

    lw $ra, 0($sp)          # restore $ra from stack ($ra <-- memory[$sp + 0])
    addiu $sp, $sp, 4       # deallocate space for $ra

    add $t9, $t2, $t3       # $t9 <-- fibonacci($t0 - 1) + fibonacci($t0 - 2)

# return $t9 in memory[$sp + 4]
fibonacci_end:
    sw $t9, 4($sp)          # return $t9 as argument OUT

    jr $ra                  # jump back to main
###########################################################
