get_min_max:
    lw $t0, 0($sp)
    lw $t1, 4($sp)
    
    lw $t2, 0($t0)      # load first element of array
    sw $t2, 8($sp)      # return array minimum
    
    addi $t1, $t1, -1   # $t1 <-- subtract 1 from array size
    sll $t1, $t1, 2     # $t1 <-- multiply $t1 by 4 
    add $t0, $t0, $t1   # add offset to array base address
    
    lw $t3, 0($t0)      # load last element of array
    sw $t3, 12($t0)     # return array maximum
    
    jr $ra
    
###############################################################

get_occurrences:
    lw $t0, 0($sp)
    lw $t1, 4($sp)     
    lw $t2, 8($sp)
    
    li $t3, 0           # initialize occurrences to 0
    
get_occurrences_loop:
    blez $t1, get_occurrences_end
    
    lw $t9, 0($t0)      # load array at index into $t9
    
    bne $t9, $t2, get_occurrences_skip   # if array element is not equal then skip
    
    addi $t3, $t3, 1    # increment occurrences
    
get_occurrences_skip:   
    addi $t0, $t0, 4    # increment array base address
    addi $t1, $t1, -1   # decrement array size
    
    b get_occurrences_loop       

get_occurrences_end:
    sw $t3, 12($sp)     # return occurrences
    
    jr $ra

###############################################################

remove_element:    
    lw $t0, 0($sp)
    lw $t1, 4($sp)     
    lw $t2, 8($sp)
    
    
    addi $sp, $sp, -4   # allocate space to backup $ra
    sw $ra, 0($sp)
    
    addi $sp, $sp, -12  # allocate space to backup $t registers
    sw $t0, 0($sp)
    sw $t1, 4($sp)     
    sw $t2, 8($sp)
    
    addi $sp, $sp, -16  # allocate space for arguments IN and OUT
    sw $t0, 0($sp)      # store arguments IN
    sw $t1, 4($sp)     
    sw $t2, 8($sp)
    
    jal get_occurrences
    
    lw $t3, 12($sp)     # load returned occurrences from stack
    addi $sp, $sp, 16
    
    lw $t0, 0($sp)      # restore backups
    lw $t1, 4($sp)     
    lw $t2, 8($sp)
    addi $sp, $sp, 12   # deallocate space for backups
    
    lw $ra, 0($sp)      # restore $ra
    addi $sp, $sp, 4    # deallocate space for $ra
    
    
remove_element_allocate:
    li $v0, 9
    sub $t8, $t1, $t3   # size of new array = size of original array - occurrences
    sll $a0, $t8, 2     # calculate number of bytes
    syscall
    
    move $t4, $v0       # put array base address into register $t4
    
    sw $t4, 12($sp)     # return address of allocated array  
    sw $t8, 16($sp)     # return size of allocates array
    
remove_element_loop:
    blez $t1, remove_element_end
    
    lw $t9, 0($t0)
    
    beq $t9, $t2, remove_element_skip   # make sure array element != given value

    sw $t9, 0($t4)      # copy values from original array into newly allocated array
    addi $t4, $t4, 4    # increment base address of newly allocated array

remove_element_skip:     
    addi $t0, $t0, 4    # increment base address of original array
    addi $t1, $t1, -1   # decrement size of original array
    
    b remove_element_loop
    
remove_element_end:
    jr $ra
    

###############################################################

contains_element:
    lw $t0, 0($sp)
    lw $t1, 4($sp)     
    lw $t2, 8($sp)
    
    li $t3, 0           # initialize index to 0
    li $t4, -1          # put constant value -1 into register $t4
    
contains_element_loop:
    blez $t1, contains_element_end      
    
    lw $t9, 0($t0)      # load array element into $t9
    
    beq $t9, $t2, contains_element_found # if we find element, then return the index
    
    addi $t0, $t0, 4
    addi $t1, $t1, -1
    addi $t3, $t3, 1    # increment index by 1
    
    b contains_element_loop

contains_element_found:
    move $t4, $t3       # put index of element into register $t4

contains_element_end:
    sw $t4, 12($sp)     # return $t4

    jr $ra  
    
    
