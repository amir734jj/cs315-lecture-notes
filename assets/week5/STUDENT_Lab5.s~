###########################################################
#       Lab 5
#   Name:
#   Date:
#
#   Note:
#       This week's lab is a modification to lab #4. more specifically we use dynamic array
#       instead of static and add one more subprograms
#  
#   Description:
#       Write a subprogram allocate_array that will ask user for an array size and then subprogram
#       allocates a dynamic array of integer with given size. thereafter, subprogram returns base
#       address of array and array size in registers $v0 and $v1 respectively. do not forget to
#       validate array size is greater than zero.
#
#       Write a subprogram print_array that will get as argument IN base address of array and 
#       array size. then it print all array elements separated by a space. in the end, it should
#       print a newline.
#
#   High level design:
#       main:
#           base address, array size <-- allocate_array()
#           store base address and array size into static variables
#
#           sum <-- read_values(base address of array, array size)
#           store sum in static variables "sum_var_p"
#
#           print sum, count and integer average           
#
#
#       allocate_array():
#           while (true) 
#               prompt for number and read number
#
#               if (number <= 0)
#                   print error message
#               else 
#                   use system call 9 to dynamically allocate an array with size == number
#                   return base address and array size in registers $v0, $v1 respectively
#
#           return base address, array size
#
#
#       print_array(base address, array size):
#           for array_element in array:
#               print array_element
#               print "space"
#           
#           print "newline"            
#
#
#       read_values(base address, array size):
#           while (array size > 0):
#               memory[base address] <-- read an odd number from console
#               base address = base address + 4
#               array size = array size - 1
#           
#           return sum
#
###########################################################
#       Register Usage
#   $t0     Holds the returned base address / sum
#   $t1     Holds the returned array size
#   $t3
#   $t4
#   $t5
#   $t6
#   $t7
#   $t8
#   $t9     temporally register
###########################################################
        .data
sum_p:          .asciiz "Sum: "
count_p:        .asciiz "Count: "        
average_p:      .asciiz "Average: "
nextline_p:     .asciiz "\n"

array_pointer_p:.word 0        # holds address of dynamic array (address)
array_size_p:   .word 0        # hold size of dynamic array (value)

sum_var_p:      .word 0        # sum variable initialized to 0
###########################################################
        .text
main:
    
    jal allocate_array
    
    move $t0, $v0
    move $t1, $v1
    
    la $t9, array_pointer_p
    sw $t0, 0($t9)

    la $t9, array_size_p
    sw $t1, 0($t9)
    
    
    
    la $t9, array_pointer_p
    lw $a0, 0($t9)

    la $t9, array_size_p
    lw $a1, 0($t9)
    
    jal read_values
    
    move $t0, $v0       # put sum into $t0
    
    la $t9, sum_var_p
    sw $t0, 0($t9)
    
    
    # print sum and average!
    
    la $t9, array_pointer_p
    lw $a0, 0($t9)

    la $t9, array_size_p
    lw $a1, 0($t9)
    
    jal print_array   
    
    
              
mainEnd:
    li $v0, 10
    syscall                     # Halt
###########################################################
#      allocate_array subprogram
#
#   Subprogram description:
#       This subprogram will receive no arguments IN but returns two arguments OUT.
#       Then, it will prompt for array size and validates input to make sure array size
#       is greater than zero ( > 0). Then, it will allocate a dynamic integer array
#       (using system call 9) and return the address of dynamic array and array size
#       into static variables (using provided references). This subprogram does not
#       get any anything as argument IN.
#
###########################################################
#       Arguments IN and OUT of subprogram
#   $a0
#   $a1
#   $a2
#   $a3
#   $v0  Holds base address of dynamic array
#   $v1  Holds array size
#   $sp
#   $sp+4
#   $sp+8
#   $sp+12
###########################################################
#       Register Usage
#   $t0  Holds array pointer (address)
#   $t1  Holds array size pointer (address)
#   $t2  Holds array size, temporarily  
###########################################################
        .data
allocate_array_prompt_p:    .asciiz "Enter size of the array to allocate (size > 0): "
allocate_array_invalid_p:   .asciiz "Array size you entered is incorrect (size > 0)!\n"
###########################################################
        .text
allocate_array:

allocate_array_end:


    jr $ra                     # jump back to the main
###########################################################    
#       read_values subprogram
#
#   Subprogram description:
#       Write an assembly sub-program that will receive as argument IN array base address and 
#       array size. then it will read a series of non-negative integers (greater than or equal to zero)
#       that are odd and then add them up to find the sum. it will stop reading values into array until 
#       array is full. finally, subprogram will return sum in register $v0
#
###########################################################
#       Arguments IN and OUT of subprogram
#   $a0     Holds base address of an array
#   $a1
#   $a2
#   $a3
#   $v0     Holds sum
#   $v1
#   $sp
#   $sp+4
#   $sp+8
#   $sp+12
###########################################################
#       Register Usage
#   $t0     Holds sum
#   $t1     Holds base address of an array (that will get incremented by 4 on each iteration)
#   $t2     Holds array size
#   $t3     
#   $t4
#   $t5
#   $t6     
#   $t7     
#   $t8     
#   $t9     Holds constant value 2
###########################################################
        .data
read_values_prompt_p:   .asciiz "Enter a non-negative integer (greater than or equal to zero) that are odd: "
read_values_invalid_p:  .asciiz "Invalid entry. Number should be odd and non-negative.\n"
###########################################################
        .text
read_values:


read_values_end:
    jr $ra                      # jump back to the main
###########################################################
#      print_array subprogram
#
#   Subprogram description:
#       This subprogram will receive as argument IN address of integer array and then
#       iterates through array and prints all elements of array. This subprogram
#       does not return anything as argument OUT.
#
###########################################################
#       Arguments IN and OUT of subprogram
#   $a0  Holds array pointer (address)
#   $a1  Holds array size (value)
#   $a2
#   $a3
#   $v0
#   $v1
#   $sp
#   $sp+4
#   $sp+8
#   $sp+12
###########################################################
#       Register Usage
#   $t0  Holds array pointer (address)
#   $t1  Holds array index
###########################################################
        .data
print_array_array_p:    .asciiz     "Array: "
print_array_space_p:    .asciiz     " "
print_array_newline_p:  .asciiz     "\n" 
###########################################################
        .text
print_array:

    
print_array_end:

    
    jr $ra                      # jump back to the main
###########################################################
