###########################################################
#       Lab 9 - Stack + read string, print character
#   Name:
#   Date:
#
#   Description:
#       complete the main subprogram. main will use system call 8 to read a string into a buffer
#       (or character array or essentially a byte array). Then main will print the string
#       character-by-character using print_character subprogram (NOT using system call 4). thereafter, 
#       main will print the string character-by-character in reverse order.
#
#   Note:
#       - ASCII characters are 1-byte
#       - ASCII value for null character is: 0
#       - ASCII value for newline character is: 10
#       - ASCII value for tab character is: 11
#       - system call to read string is: 8
#       - system call to print character is: 11
#       - if buffer size is 20, then we can only input (20 - 1) characters into character array because
#         one character should be null terminated character (or ASCII value 0)
#
#   Pseudo-code
#       print enter_p via system call 4
#       character_array_p <-- read string via system call 8
#
#       *** print character_array_p character-by-character using print_character subprogram
#       
#       *** print character_array_p in a reversed order character-by-character using print_character subprogram
#
#
#   Sample run:
#        Enter a string: Hello World!
#        Entered string was: Hello World!
#        Reverse of string: !dlroW olleH
#
###########################################################
#       Register Usage
#   $t0     Holds base address of character array
#   $t1     Holds size of character array
#   $t2
#   $t3
#   $t4
#   $t5
#   $t6
#   $t7
#   $t8
#   $t9     temporarily
###########################################################
		.data
enter_p:                .asciiz "Enter a string: "
string_p:               .asciiz "Entered string was: "
reversed_p:             .asciiz "Reverse of string: "
        
character_array_p:      .space  20      # character array (or array of bytes)
character_array_size_p: .word   20      # character array size
###########################################################
		.text
main:
# initialization
	la $t0, character_array_p       # put buffer or base address of character into $t0
	
	la $t9, character_array_size_p  # $t9 <--  address of character_array_size_p variable
    lw $t1, 0($t9)                  # put buffer size of size of character array into $t1


	li $v0, 4                       # prompt for a string to read from console
	la $a0, enter_p
	syscall

	li $v0, 8                       # read a string via system call 8
	move $a0, $t0                   # pass base address of character array as a buffer
	move $a1, $t1                   # pass array size as a buffer
	syscall

	li $v0, 4                       # print string is:
	la $a0, string_p
	syscall

# prints string is a regular way:
print_string_normal_loop:
	blez $t1, print_string_normal_end   # branch if array size (countdown) is equal to zero

	lb $t9, 0($t0)                  # fetch character from character array into $t9

	addi $sp, $sp, -4               # allocate space for $ra on the stack
	sw $ra, 0($sp)                  # store $ra on the stack

	addi $sp, $sp, -8               # allocate space for backups on the stack ($t0, $t1)
	sw $t0, 0($sp)                  # store $t0 as a backup on the stack
	sw $t1, 4($sp)                  # store $t1 as a backup on the stack

	addi $sp, $sp, -1               # allocate space for argument IN and OUT on the stack
	                                # argument IN: character to be printed (1 byte)
                                    # argument OUT: NONE
                                    
	sb $t9, 0($sp)                  # store character to printed on the stack

	jal print_character             # call subprogram print_character

	addi $sp, $sp, 1                # deallocate space for argument IN and OUT

	lw $t0, 0($sp)                  # restore $t0 from [$sp + 0]
	lw $t1, 4($sp)                  # restore $t0 from [$sp + 4]
	addi $sp, $sp, 8                # deallocate space for backups

	lw $ra, 0($sp)                  # restore $ra from the stack
	addi $sp, $sp, 4                # deallocate space for $ra

	addi $t0, $t0, 1                # increment base address of character array by 1 (ASCII character = 1 byte)
	addi $t1, $t1, -1               # decrement array size by 1 (we are using array sizer as a countdown)

	b print_string_normal_loop      # branch unconditionally to beginning of the loop
	
print_string_normal_end:	
    li $v0, 11                      # print newline character
    li $a0, 10                      # ASCII character for newline is 10                      
    syscall
    
    li $v0, 4                       # print reverse of string is:
    la $a0, reversed_p
    syscall


# restore $t0 and $t1 from static variables
	la $t0, character_array_p       # put buffer or base address of character into $t0
	
	la $t9, character_array_size_p  # $t9 <--  address of character_array_size_p variable
    lw $t1, 0($t9)                  # put buffer size of size of character array into $t1


# adjust base address of character array to be printed in a reverse order ($t0 should point to last character)	
	addi $t9, $t1, -1               # $t9 <-- $t1 - 1
	add $t0, $t0, $t9               # $t0 <-- $t0 + $t0


# prints string in a reversed way
print_string_reverse_loop:
	blez $t1, print_string_reverse_end   # branch if array size (countdown) is equal to zero

	lb $t9, 0($t0)                  # fetch character from character array into $t9

	addi $sp, $sp, -4               # allocate space for $ra on the stack
	sw $ra, 0($sp)                  # store $ra on the stack

	addi $sp, $sp, -8               # allocate space for backups on the stack ($t0, $t1)
	sw $t0, 0($sp)                  # store $t0 as a backup on the stack
	sw $t1, 4($sp)                  # store $t1 as a backup on the stack

	addi $sp, $sp, -1               # allocate space for argument IN and OUT on the stack
	                                # argument IN: character to be printed (1 byte)
                                    # argument OUT: NONE
                                    
	sb $t9, 0($sp)                  # store character to printed on the stack

	jal print_character             # call subprogram print_character

	addi $sp, $sp, 1                # deallocate space for argument IN and OUT

	lw $t0, 0($sp)                  # restore $t0 from [$sp + 0]
	lw $t1, 4($sp)                  # restore $t0 from [$sp + 4]
	addi $sp, $sp, 8                # deallocate space for backups

	lw $ra, 0($sp)                  # restore $ra from the stack
	addi $sp, $sp, 4                # deallocate space for $ra

	addi $t0, $t0, -1               # decrement base address of character array by 1 (ASCII character = 1 byte)
	addi $t1, $t1, -1               # decrement array size by 1 (we are using array sizer as a countdown)

	b print_string_reverse_loop     # branch unconditionally to beginning of the loop
	
print_string_reverse_end:	

mainEnd:
	li $v0, 10                      # halt
	syscall
###########################################################
#       print_character subprogram
#
#   Subprogram description:
#       this subprogram will receive as argument IN a character (which is 1-byte) to be printed.
#       then subprogram passes the character to system call 11 which prints characters. if
#       character is 0 OR 10 then subprogram will not print that character.
#
#   Note:
#       this subprogram is complete, please DO NOT modify it.
#
###########################################################
#       Arguments IN and OUT of subprogram
#   $sp+0  character to be printed (IN)
###########################################################
#       Register Usage
#   $t0  Holds the character to be printed
#   $t1  Holds constant value 0
#   $t2  Holds constant value 10
###########################################################
		.data
###########################################################
		.text
print_character:
	lb $t0, 0($sp)                  # load the character to be printed into $t0
	li $t1, 0                       # set $t1 to be 0 (null character is 0)
	li $t2, 10                      # set $t2 to be 10 (newline character is 10)

	beq $t0, $t1, print_character_end   # if character is null then skip printing that character
	beq $t0, $t2, print_character_end   # if character is newline then skip printing that character

	li $v0, 11                      # print the character via system call 11
	move $a0, $t0                   # pass the character to be printed as argument IN for system call 11
	syscall

print_character_end:
	jr $ra                          # jump back to main
###########################################################	
