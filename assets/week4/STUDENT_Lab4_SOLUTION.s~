###########################################################
#       Lab 4
#   Name:
#   Date:
#
#   Note:
#       Take a screenshot of data section of QtSPIM (which would imply that entered values
#       are correctly stored in memory) and submit it to D2L as well.     
#  
#   Description:
#       Write main and subprogram names: read_values.
#
#       main: it initialize two static variables sum_var_p and count_var_p and also
#       static array of 10 integers (array_p). then main will call subprogram read_values
#       and pass base address of static array as an argument IN and store the returned
#       (or argument OUT) sum and count into static variables sum_var_p and count_var_p
#
#
#       read_values: this subprogram is the same as solution of Program #1, so copy the
#       solution of program #1 into read_values subprogram. then modify the code as following:
#           
#           1- prepend subprogram name (read_values) to label and variable names
#             for example: loop      --> read_values_loop
#                          prompt_p  --> read_values_prompt_p
#                          main      --> read_values       
#
#           2- modify the code so subprogram will get as argument IN in register $a0 a base address
#             of an array
#
#           3- modify the code so program stores the valid numbers into the array. because in program #1
#             "count" can never exceed 10, then we should never get an array overflow exception 
#
#           4- modify the code so subprogram will return sum and count in registers $v0 and $v1
#             respectively
#
#           5- move the code that prints sum, count and integer average into main so printing
#               results are all done in main instead read_values subprogram             
#
#   High level design:
#       main:
#           sum & count <-- read_values(base address of array)
#           
#           store sum & count in static variables "sum_var_p", "count_var_p" respectively
#
#           print sum, count and integer average           
#
#       read_values(base address):
#           initialize sum and count to 0
#
#           while (true) {
#               prompt for number and read number
#
#               if (number == -7 || count == 10) {
#                   break
#               }
#               
#               if (number < 0) {
#                   print error message
#               } 
#                            
#               array[base address] = number
#               base address = base address + 4     // because integers are 4 bytes in MIPS
#                                                   // and addresses in MIPS are in bytes
#
#               sum = sum + number
#               count = count + 1
#           }
#
#           return sum & count in register $v0 and $v1 respectively
#
###########################################################
#       Register Usage
#   $t0     Holds the returned sum
#   $t1     Holds the returned count
#   $t3
#   $t4
#   $t5
#   $t6
#   $t7
#   $t8
#   $t9     temporally register
###########################################################
        .data
sum_p:          .asciiz "Sum: "
count_p:        .asciiz "Count: "        
average_p:      .asciiz "Average: "
nextline_p:     .asciiz "\n"

array_p:        .word 0:10      # array of 10 integers each initialized to 0  
        
sum_var_p:      .word 0         # sum variable initialized to 0
count_var_p:    .word 0         # count variable initialized to 0
###########################################################
        .text
main:
# calling subprogram read_values
    la $a0, array_p             # put base address of static array of size = 10 into
                                # register $a0
                                        
    jal read_values             # call read_values subprogram
                                # arguments IN: base addresses of integer array size = 10
                                # arguments OUT: sum & count

    move $t0, $v0               # copy returned sum into register $t0 
    move $t1, $v1               # copy returned count into register $t1
    
    
# copied from solution of Lab #3
# store sum and count into static variable
    la $t9, sum_var_p           # load address of static variable sum_p into $t9
    sw $t0, 0($t9)              # memory[$t9 + 0] <-- $t0

    la $t9, count_var_p         # load address of static variable count_p into $t9
    sw $t1, 0($t9)              # memory[$t9 + 0] <-- $t1


# copied from solution of Program #1    
    li $v0, 4                   # print sum is
    la $a0, sum_p
    syscall

    li $v0, 1                   # print sum integer
    move $a0, $t0
    syscall

    li $v0, 11                  # print newline character
    li $a0, 13
    syscall

    li $v0, 4                   # print count is
    la $a0, count_p
    syscall

    li $v0, 1                   # print count integer
    move $a0, $t1
    syscall

    li $v0, 11                  # print newline character
    li $a0, 13
    syscall

    li $v0, 4                   # print average is
    la $a0, average_p
    syscall

    beqz $t1, divide_by_zero    # if count is zero, we should not divide sum by zero
    
    li $v0, 1                   # print quotient
    div $a0, $t0, $t1           # divide sum by count and put quotient in register $a0
    syscall

    b exit                      # branch unconditionally to halt

divide_by_zero:
    li $v0, 1                   # print zero
    move $a0, $0
    syscall

exit:

mainEnd:
    li $v0, 10
    syscall                     # Halt
###########################################################
#       read_values subprogram
#
#   Subprogram description:
#       Write an assembly sub-program that will read a series of non-negative integers (greater than or equal to zero)
#       that are odd, count them and then add them up. It will stop reading when -7 is entered OR count of numbers
#       becomes 10, it will print out an error for all invalid inputs and those invalid entries will be ignored. After
#       all the integers are read, Program will output the sum, count and integer average.
#
###########################################################
#       Arguments IN and OUT of subprogram
#   $a0     Holds base address of an array
#   $a1
#   $a2
#   $a3
#   $v0     Holds sum
#   $v1     Holds count
#   $sp
#   $sp+4
#   $sp+8
#   $sp+12
###########################################################
#       Register Usage
#   $t0     Holds sum/remainder
#   $t1     Holds count
#   $t2     Holds base address of an array (that will get incremented by 4 on each iteration)
#   $t3     
#   $t4
#   $t5
#   $t6     Holds remainder of dividing number by 2
#   $t7     Holds constant value -7
#   $t8     Holds constant value 10
#   $t9     Holds constant value 2
###########################################################
        .data
read_values_prompt_p:   .asciiz "Enter a non-negative integer (greater than or equal to zero) that are odd: "
read_values_invalid_p:  .asciiz "Invalid entry. Number should be odd and non-negative.\n"
###########################################################
        .text
read_values:
# load argument IN:
    move $t2, $a0               # load base address of array and put in register $t2
    
    li $t0, 0                   # initialize sum to zero
    li $t1, 0                   # initialize count to zero
    li $t7, -7                  # initialize $t7 to constant value -7     
    li $t8, 10                  # initialize $t8 to constant value 10  
    li $t9, 2                   # initialize $t9 to constant value 2      
      
read_values_entry_loop:
    li $v0, 4                   # prompt for number
    la $a0, read_values_prompt_p
    syscall

    li $v0, 5                   # read integer
    syscall

    beq $t1, $t8, read_values_calculation   # branch to calculation if count value is 10
    beq $v0, $t7, read_values_calculation   # branch to calculation if value is -7
    
    bltz  $v0, read_values_invalid_entry    # branch to invalid_entry if value is less than zero
    
    rem $t6, $v0, $t9                       # divide the number by 2 and put entry into register $t6
    beqz $t6, read_values_invalid_entry     # branch to invalid_entry if value is even
    
    add $t0, $t0, $v0                       # add the number to the sum
    addi $t1, $t1, 1                        # increment count by 1
    
    sw $v0, 0($t2)                          # store the valid number into array
    addi $t2, $t2, 4                        # increment base address of array by 4 because integers
                                            # are 4 bytes and addresses in MIPS are in bytes

    b read_values_entry_loop                # branch unconditionally to the beginning of the loop

read_values_invalid_entry:
    li $v0, 4                   # print error message
    la $a0, read_values_invalid_p
    syscall

    b read_values_entry_loop    # branch unconditionally to read_values_entry_loop

read_values_calculation:
# return arguments OUT
    move $v0, $t0               # return sum in register $v0
    move $v1, $t1               # return count in register $v1

read_values_end:
    jr $ra                              # jump back to the main
###########################################################
