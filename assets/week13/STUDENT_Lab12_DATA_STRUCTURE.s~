###########################################################
#       Lab 13 - data structures, modification
#
#   Name:
#   Date:
#
#   Description:
#       1. call create_array to create an array of data structures
#       2. call print_table to print a table of the data structures
#       3. call get_stats to get information about all data structures in the array
#
#   Difference of lab #12 and #13:
#       in this lab, we change integer to single precision floating point and we introduce string 
#       of character array into data structure. 
#
#   High level design:
#       from main call: <-- array base address, array size <-- create_array()
#           from create_array call: null <-- read_array(array base address, array size)
#           
#       from main call: null <-- print_table(array base address, array size)
#
#       from main call: array sum, array average <-- get_stats(array base address, array size)
#
#       from main: print array sum
#       from main: print array average
#
#   Data structure (total size = 8 + 4 + 20 = 32 = 2^5):
#       offset 0 --> double-precision value
#       offset 8 --> single precision value
#       offset 12--> array of characters or integers, size of array = 20 bytes
#
#   Design:
#       [
#           [1.5   1.1     'A', B', 'C', '\0'],
#           [2.5   2.1     'D', E', 'F', '\0']
#       ]
#   
#   Formula:
#       sum = (1.5 * 1.1) + (2.5 * 2.1)  = 6.9
#       average = (1.5 * 1.1) + (2.5 * 2.1) / 2 = 3.45
#       
###########################################################
        .data
average_p:      .asciiz "Average: "
total_p:        .asciiz "Total: "

# declare words to hold dynamic array base and array size
array_pointer_p:      .word 0   # holds address dynamic array pointer (address)
array_size_p:         .word 0   # hold size of dynamic array (value)
###########################################################
        .text
main:
# calling a subprogram create_array to dynamically allocate data structure
    addi $sp, $sp, -4           # allocate one word for $ra
    sw $ra, 0($sp)              # store $ra on stack

                                # no register to backup in the stack
                            
    addi $sp, $sp, -8           # allocate words for the arguments
                                # arguments IN: NONE
                                # arguments OUT: array base address, array size <-- 2 words
                                
    jal create_array            # call subprogram create_array
    
    lw $t0, 0($sp)              # read array base address from stack
    lw $t1, 4($sp)              # read array size from stack
    addi $sp, $sp, 8            # deallocate words for the arguments
    
                                # we did not backup a register, so there is no register restoring 
    
    lw $ra, 0($sp)              # load $ra from stack
    addi $sp, $sp, 4            # deallocate word for $ra


    
# store array base address and array size into static variables
    la $t9, array_pointer_p     # store array base address into static variable
    sw $t0, 0($t9)

    la $t9, array_size_p        # store array base size into static variable
    sw $t1, 0($t9)


# calling a subprogram print_table to print the data structures

# restore array base address and array size from static variables
    la $t9, array_pointer_p     # store array base address into static variable
    lw $t0, 0($t9)

    la $t9, array_size_p        # store array base size into static variable
    lw $t1, 0($t9)  
    
    addi $sp, $sp, -4           # allocate one word for $ra
    sw $ra, 0($sp)              # store $ra on stack

                                # no register to backup in the stack
                            
    addi $sp, $sp, -8           # allocate words for the arguments
                                # arguments IN: array base address, array size  <-- 2 words
                                # arguments OUT: NONE
                                    
    sw $t0, 0($sp)              # store array base address on stack
    sw $t1, 4($sp)              # store array size on stack

    jal print_table             # call subprogram print_table

    addi $sp, $sp, 8            # deallocate words for the arguments
    
                                # we did not backup a register, so there is no register restoring 
    
    lw $ra, 0($sp)              # load $ra from stack
    addi $sp, $sp, 4            # deallocate word for $ra
    
    
    
# calling a subprogram get_stats to get statistics about the data structures (sum and average)

# restore array base address and array size from static variables
    la $t9, array_pointer_p     # store array base address into static variable
    lw $t0, 0($t9)
    la $t9, array_size_p        # store array base size into static variable
    lw $t1, 0($t9)  
    
    addi $sp, $sp, -4           # allocate one word for $ra
    sw $ra, 0($sp)              # store $ra on stack

                                # no register to backup in the stack
                            
    addi $sp, $sp, -24          # allocate words for the arguments
                                #   2 arguments IN:     array base address, array size
                                #   2 arguments OUT:    array sum and array average
                                
    sw $t0, 0($sp)              # store array base address on stack
    sw $t1, 4($sp)              # store array size on stack

    jal get_stats               # call subprogram get_stats

    l.d $f0, 8($sp)             # load array sum from stack
    l.d $f2, 16($sp)            # load array average from stack
    
    addi $sp, $sp, 24           # deallocate words for the arguments
    
                                # we did not backup a register, so there is no register restoring 
    
    lw $ra, 0($sp)              # load $ra from stack
    addi $sp, $sp, 4            # deallocate word for $ra


# print array sum and array average 

# print new line character  
    li $a0, 10                  # print new line character (ASCII code 10)
    li $v0, 11
    syscall 
    
    li $v0, 4                   # array sum is:
    la $a0, total_p
    syscall
    
    li $v0, 3                   # print array sum value
    mov.d $f12, $f0
    syscall

# print new line character  
    li $a0, 10                  # print new line character (ASCII code 10)
    li $v0, 11
    syscall 
    
    li $v0, 4                   # array average is:
    la $a0, average_p
    syscall
    
    li $v0, 3                   # print array average value
    mov.d $f12, $f2
    syscall
    
mainEnd:
    li $v0, 10
    syscall                     # Halt
###########################################################
#       create_array subprogram
#
#   Subprogram description:
#       1) ask the user for an array length
#       2) call read_array to fill the array
#   
#           - use offset 0 to store double precision
#           - use offset 8 to store single precision
#           - use offset 12 as a base address for character array of 20 bytes
#
#       therefore, each structure requires 8 + 4 + 20 = 32 = 2^5 bytes
#
#  Example:
#    data structure:
#       [
#           [1.5   1.1     'A', B', 'C', '\0'],
#           [2.5   2.1     'D', E', 'F', '\0']
#       ]
#
###########################################################
#       Arguments IN and OUT of subprogram
#   $sp+0   Holds array base address (OUT)
#   $sp+4   Holds array length (OUT)
###########################################################
#       Register Usage
#   $t0     Holds array index address
#   $t1     Holds array length/loop countdown
#   $t2     constant value 12
###########################################################
        .data
create_array_length_p:  .asciiz "Enter an array length (or data structure size):  "
create_array_invalid_p: .asciiz "Invalid length\n"
###########################################################
        .text
create_array:

create_array_loop:
    li $v0, 4                   # prompt for array size
    la $a0, create_array_length_p
    syscall
    
    li $v0, 5                   # read array size (integer)
    syscall
    
# check for valid array size > 0
    bgtz $v0, create_array_valid_size       # if array size is greater than zero, then branch to valid_size
    
create_array_invalid_size:
    li $v0, 4                   # print invalid array size error message
    la $a0, create_array_invalid_p
    syscall
            
    b create_array_loop         # branch unconditionally to the prompt
    
create_array_valid_size:
    sw $v0, 4($sp)              # store array size in 4($sp)
    move $t1, $v0               # copy array size into register $t1

#
# TODO:
#   given array size in $t0, allocate an array using system call 9
#   each structure is 32 bytes or 2^5
#
#   

    sw $v0, 0($sp)              # store array base address in 0($sp)
    move $t0, $v0               # copy array base address into register $t0

# print new line character  
    li $a0, 10                  # print new line character (ASCII code 10)
    li $v0, 11
    syscall
    
# calling a subprogram read_array to read values into data structure
    addi $sp, $sp, -4           # allocate one word for $ra
    sw $ra, 0($sp)              # store $ra on stack

                                # no register to backup in the stack
                            
    addi $sp, $sp, -8           # allocate words for the arguments
                                # arguments IN: array base address, array size  <-- 2 words
                                # arguments OUT: NONE
                                
    sw $t0, 0($sp)              # store array base address on stack
    sw $t1, 4($sp)              # store array size address on stack 
    jal read_array              # call subprogram read_array

    addi $sp, $sp, 8            # deallocate words for the arguments
    
                                # we did not backup a register, so there is no register restoring 
    
    lw $ra, 0($sp)              # load $ra from stack
    addi $sp, $sp, 4            # deallocate word for $ra   
    
create_array_end:   
    jr $ra                      # jump back to the main
###########################################################
#       read_array subprogram
#
#   Subprogram description:
#       1) reads data structures into the array until the array is full
#       2) store double, float and character array at the correct offsets
#
#           - use offset 0 to store double precision
#           - use offset 8 to store single precision
#           - use offset 12 as a base address for character array of 20 bytes
#
#  Example:
#    data structure:
#       [
#           [1.5   1.1     'A', B', 'C', '\0'],
#           [2.5   2.1     'D', E', 'F', '\0']
#       ]
#
###########################################################
#       Arguments IN and OUT of subprogram
#   $sp+0   Holds array base address (IN)
#   $sp+4   Holds array length (IN)
###########################################################
#       Register Usage
#   $t0     Holds array index address
#   $t1     Holds array length/loop countdown
###########################################################
        .data
read_array_float_p:    .asciiz "Enter an float: "
read_array_double_p:   .asciiz "Enter a double: "
read_array_string_p:   .asciiz "Enter a string: "
###########################################################
        .text
read_array:
# TODO:
#   complete this subprogram. you can use solution of lab 12 as a starting point.
    
read_array_end:
    jr $ra                      # jump back to the main
###########################################################
#       print_table subprogram
#
#   Subprogram description:
#       1) prints all data structures in the array
#       2) prints the doubles followed by the float and then string, separated by four spaces (or tab character)
#
#           - use offset 0 to store double precision
#           - use offset 8 to store single precision
#           - use offset 12 as a base address for character array of 20 bytes
#
#  Example:
#    data structure:
#       [
#           [1.5   1.1     'A', B', 'C', '\0'],
#           [2.5   2.1     'D', E', 'F', '\0']
#       ]
#
#   Note:
#       ASCII code 9 is a horizontal tab.
#       ASCII code 10 is a newline character.
#       system call to print a character is: 11
#
#   Example:
#       1.5    1.1  ABC
#       2.5    2.1  DEF
#
###########################################################
#       Arguments IN and OUT of subprogram
#   $sp+0   Holds array base address (IN)
#   $sp+4   Holds array length (IN)
###########################################################
#       Register Usage
#   $t0     Holds array index address
#   $t1     Holds array length/loop countdown
###########################################################
        .data
print_table_structs_p:  .asciiz "Data table:\n"
###########################################################
        .text
print_table:
# TODO:
#   complete this subprogram. you can use solution of lab 12 as a starting point.
    
print_table_end:
    jr $ra                      # jump back to the main
###########################################################
#       get_stats subprogram
#
#   Subprogram description:
#       1) calculates average and total value of array
#       2) average is the sum of all doubles divided by the number of elements in the array
#       3) total is the sum of all doubles, each multiplied by integer in the same data structure
#
#   Example:
#       [
#           [1.5   1.1     'A', B', 'C', '\0'],
#           [2.5   2.1     'D', E', 'F', '\0']
#       ]
#   
#   Formula:
#       sum = (1.5 * 1.1) + (2.5 * 2.1)  = 6.9
#       average = (1.5 * 1.1) + (2.5 * 2.1) / 2 = 3.45
#
###########################################################
#       Arguments IN and OUT of subprogram
#   $sp+0   Holds array base address (IN)
#   $sp+4   Holds array length (IN)
#   $sp+8   Holds sum value of array (OUT)
#   $sp+16  Holds average value of all doubles (OUT)
###########################################################
#       Register Usage
#   $t0     Holds array index address
#   $t1     Holds array length/loop countdown
#   $t2     Holds Integer from structure
#   $f4|$f5 Holds array sum (double * integer)
#   $f6|$f7 Holds array average (double * integer) / count
#   $f8|$f9 Holds array size in double
#   $f10|$f11   Holds array value / TEMP
#   $f12|$f13   TEMP
###########################################################
        .data
###########################################################
        .text
get_stats:
# TODO:
#   complete this subprogram. you can use solution of lab 12 as a starting point.
    
get_stats_end:

    
    jr $ra                      # jump back to the main
###########################################################
